%debug

%{
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <assert.h>
   /*#include "parser.h"*/
   #include "nodes.h"
   #include "ampl.h"
   #include "StochModel.h"
   #include "StochModelComp.h"
   #include "symtab.h"
   #include "backend.h"
   int yylex(void);
   void yyerror(char *s);
   /* global variables */
   static AmplModel *current_model;   /* this is the model currently active */
                                       /* this is the GLOBAL context */
   static AmplModel *local_context;   /* this is the LOCAL context */
   static int use_local;               /* flag to indicate that local should
					  be used */
   static opNodeIx *list_of_indexing[20];   /* list of currently applicable 
					    indexing expressions */
   static int n_indexing;
   /* ---------------- stochastic global variables:------------------------ */
   static bool is_stoch_model;      /* true if inside stochastic model def */
   /* these are set within entity definitions and reset at the end of them */
   static bool is_deterministic_loc;
   static opNode *stages_loc;
   /* these are set by global stocastic modifier commands */
   static bool is_deterministic_glo;
   static opNode *stages_glo;
   static char *modelfilename;
   static char *datafilename;
   extern FILE *yyin;
   extern void parse_data(AmplModel *current_model, char *datafilename);

   void add_cons_to_model(char *id, opNode *indx, opNode *attrib);
   void add_param_to_model(char *id, opNode *indx, opNode *attrib);
   void add_var_to_model(char *id, opNode *indx, opNode *attrib);
   void addStochInfo(StochModelComp *newmc);
%}

%union
{
  int optype;
  long *ival;
  double *fval;
  char *string;
  opNode *opPtr;
  opNodeIx *opPtrIx;
  //retType *ret;
  //relNode *relPtr;
  //indexNode *indexPtr;
}

%type <string> cnstr
%type <opPtr> expr value  equation expr_list 
%type <opPtr> setattributes setattribute 
%type <opPtr> stochattr_opt
%type <opPtr> paramattributes_opt paramattributes paramattribute 
%type <opPtr> varattributes_opt varattributes varattribute 
 //%type <opPtr> csattributes_opt csattributes csattribute 
%type <opPtr> setexpr_list lexpr 
%type <opPtr> setexpression identifier iditem setexpr_item dummy_member
%type <opPtr> commasepoptions optionlist
%type <opPtrIx> indexing indexing_opt
%type <optype> relop reduction_op func

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITY COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE
%token NET_IN NET_OUT DIMEN ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED LOGICAL_OR LOGICAL_AND ELLIPSE
%token PUBLIC CORE DOT BEG TIMESTAGE RANDOM SUFFIX BLOCK IDREF IDREFM
%token SBLOCK USING DETERMINISTIC EXPECTATION STOCHASTIC STAGES
%token STAGE NODE

%right ASSIGN
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NE
%left LT LE GT GE
%left '+' '-'
%left '*' '/'
%right POWER
%left '!'
%left ELLIPSE

%%
statements: /* empty */
          | statements statement 
          ;

block: modelblock
     | coreblock
     | stochblock
     | blockblock
     ;

modelblock: modelblockbegin statements modelblockend

/* a model command sets up a submodel of the current model */
modelblockbegin: MODEL ID optionlist {begin_model((char *)$2, NULL);}
               | MODEL MODELTYPE ID optionlist {begin_model((char*)$3, NULL);}
               ;

modelblockend: END MODEL {end_model();}

optionlist: /*empty */ {$$=NULL;}
          | LBRACKET commasepoptions RBRACKET {$$=$2;}
          ;

commasepoptions: identifier {
	            $$ = newUnaryOp(COMMA, $1);}
               | commasepoptions COMMA identifier{
		 $$ = addItemToListNew($1, $3);
                  }
               ;
/* -------------------------------------------------------------------- 
  blockblock
------------------------------------------------------------------------- */
/* A blockblock is a block definition of the form

     block name{indexing}:
       statements
     end block;

which means that all the statements within the block are repeated over the
indexing expression 
*/

blockblock: blockblockbegin statements blockblockend

blockblockbegin: BLOCK ID indexing_opt COLON {
                    add_indexing($3);
                    begin_model((char*)$2, $3); }

blockblockend: END BLOCK SEMICOLON {end_model();
		 rem_indexing(NULL);
               }
/* -------------------------------------------------------------------- 
  stochblock
------------------------------------------------------------------------- */
/* A stochblock is a block definition of the form

     [sblock/stochastic block] name{indexing} using (STAGES,NODES,ANC,PROB):
       statements
     end sblock;

where 
  STAGES: set of time stages 
  NODES: set of nodes in the tree
  ANC{NODES}: ancestor for every node
  PROB{NODES}: conditional probability of reaching this node from parent

  The whole block is repeated over all STAGES (actually over all NODES). 
  Entities marked 'deterministic' are only repeated over STAGES

--------------------------------------------------------------------
Logic of stochastic qualifiers: deterministic/stages:
 - if an sblock is started, then is_stoch_model is set to true
 - if an sblock is closed, then is_stoch_model is set to false
 - deterministc/stages are read in as attributes to param/set/var/etc defs
 - their value is stored in global variables stages/is_deterministic




*/

stochblock: sblockbegin statements sblockend
          | stochblockbegin statements stochblockend

/* FIXME: optionlist is of form '(ID COMMA ID ...)'
	  need to call newUnaryOp and addToListItem functions in the 
	  processing of optionlist and its children */
stochblockbegin: STOCHASTIC BLOCK ID indexing_opt USING optionlist COLON {
                    add_indexing($4);
                    begin_smodel((char*)$3, $4, $6); }

sblockbegin: SBLOCK ID indexing_opt USING optionlist COLON {
                    add_indexing($3);
                    begin_smodel((char*)$2, $3, $5); }

stochblockend: END STOCHASTIC BLOCK SEMICOLON {end_model();
		 rem_indexing(NULL);
               }

sblockend: END SBLOCK SEMICOLON {end_smodel();
		 rem_indexing(NULL);
               }

/* -------------------------------------------------------------------- 
  coreblock
------------------------------------------------------------------------- */

coreblock: BEG CORE statements END CORE


statement: setdef SEMICOLON
         | paramdef SEMICOLON
         | vardef SEMICOLON
//         | defn SEMICOLON
//         | assignment SEMICOLON
         | cnstr SEMICOLON
         | command SEMICOLON
         | block
         | INCLUDE ID SEMICOLON
         | set_default COLON
         ;

set_default: TIMESTAGE INT_VAL
           ;

/* FIXME */
command: SOLVE
       | LET indexing identifier DEFINED expr
       ;

/* the first three items define a var/parameter */
//assignment: defn ASSIGN expr
//          | defn EQ expr
//          | defn bd_list
//          | equation
//          ;

/* this looks to be redundant: used from assignment */
//bd_list: bd_list COMMA bound
//       | bound
//       ;

relop: LE {$$=LE;}
     | GE {$$=GE;}
     | LT {$$=LT;}
     | GT {$$=GT;}
     | ASSIGN {$$=ASSIGN;}
     | EQ {$$=EQ;}
     | NE {$$=NE;}
     ;

/* this looks to be redundant: used from bd_list */
//bound: LE expr
//     | LT expr
//     | GE expr
//     | GT expr
//     ;

equation: expr ASSIGN expr { $$ = newBinOp(ASSIGN, $1, $3); }
        | expr LT expr { $$ = newBinOp(LT, $1, $3); }
        | expr LE expr { $$ = newBinOp(LE, $1, $3); }
        | expr GT expr { $$ = newBinOp(GT, $1, $3); }
        | expr GE expr { $$ = newBinOp(GE, $1, $3); }
        | expr EQ expr { $$ = newBinOp(EQ, $1, $3); }
        ;

cnstr: MAXIMIZE ID indexing_opt {if ($3) add_indexing($3);} stochattr_opt COLON expr {
          defineSymbol(MAXIMIZE, $2, $3, current_model); 
	  add_obj_to_model(MAXIMIZE, $2, $3, $7);	  
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
     | MINIMIZE ID indexing_opt {if ($3) add_indexing($3);} stochattr_opt COLON expr {
          defineSymbol(MINIMIZE, $2, $3, current_model); 
	  add_obj_to_model(MINIMIZE, $2, $3, $7);	  
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
     | SUBJECTTO ID indexing_opt {if ($3) add_indexing($3);} stochattr_opt COLON equation { 
          defineSymbol(SUBJECTTO, $2, $3, current_model); 
	  add_cons_to_model($2, $3, $7);
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
     ;

//csattributes_opt: /* empty */ {$$=NULL;}
//                 | csattributes {$$ = $1;}
//                 ;


//csattributes: csattribute {
//                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
//             | csattributes COMMA csattribute{
// 	          $$ = addItemToListOrCreate(COMMA, $1, $3);
//	     }
//             ;

//csattribute: STAGES setexpression {
//               $$ = NULL;
//	       stages = $2;
//             }
//           ;

indexing_opt: /* empty */ {$$=NULL;}
            | indexing {$$=$1;}
            ;

indexing: LBRACE setexpr_list COLON lexpr RBRACE {
	   opNode *tmp = newUnaryOp(LBRACE, newBinOp(COLON, $2, $4));
           $$ = new opNodeIx(tmp);
          }
        | LBRACE setexpr_list RBRACE {
	    opNodeIx *tmp = new opNodeIx(newUnaryOp(LBRACE, $2));
	    $$=tmp;
          }
        ;

//domain: /* empty */ { $$=NULL }
//      | LBRACE setexpr_list RBRACE {/* $$ = $2*/ }
         ;

/* FIXME: ID IN setexpression defines a dummy variable (?)
   -> have this as a separate construct
   -> how to deal with dummy variables? */
setexpr_list: setexpr_item
            | setexpr_list COMMA setexpr_item{
                if ($1->opCode==COMMA){
		  $$ = addItemToListNew($1, $3);
		}else{
		  $$ = newBinOp(COMMA, $1, $3);
		}
              }
            ;

setexpr_item : setexpression
             | dummy_member IN setexpression{
               $$ = newBinOp(IN, $1,$3);}
             ;

dummy_member : ID {$$=newUnaryOp(ID, $1);}
             | LBRACKET ID COMMA ID RBRACKET {
	        opNode *tmp = newUnaryOp(LBRACKET, 
   	          newBinOp(COMMA, newUnaryOp(ID,$2), newUnaryOp(ID,$4)));
	       $$ = tmp;}
             ;

lexpr: expr
     | LBRACKET lexpr RBRACKET {
	$$ = newUnaryOp(LBRACKET, $2); }
     | equation
     ;

setdef: SET ID indexing_opt {if ($3) add_indexing($3);} stochattr_opt setattributes{ 
          defineSymbol(SET, $2, $3, current_model); 
	  add_set_to_model($2, $3, $6);
	  if ($3) rem_indexing($3);
	  //$$=$2; 
        };

/* qualifier can be public/random: is this redundant? */
paramdef: qualifier PARAM ID indexing_opt {if ($4) add_indexing($4);} stochattr_opt paramattributes_opt{
            defineSymbol(PARAM, $3, $4, current_model); 
	    add_param_to_model($3, $4, $7);
	    if ($4) rem_indexing($4);
	    //$$=$2; 
          };

vardef: VAR ID indexing_opt {if ($3) add_indexing($3);} stochattr_opt varattributes_opt{
            defineSymbol(VAR, $2, $3, current_model); 
	    add_var_to_model($2, $3, $6);
   	    if ($3) rem_indexing($3);
	    //$$=$2; 
          };



qualifier: /* empty */
         | PUBLIC
         | RANDOM
         ;

/* these are SET definitions */

setattributes: /* empty */ {$$=NULL;}
             | setattributes setattribute {
  	         $$ = newBinOp(' ', $1, $2); }
             ;

setattribute: DIMEN INT_VAL {
                 $$ = newUnaryOp(DIMEN, newUnaryOp(INT_VAL, $2));}
            | WITHIN setexpression {
                 $$ = newUnaryOp(WITHIN, $2);}
            | ASSIGN setexpression {
                 $$ = newUnaryOp(ASSIGN, $2);}
            | DEFAULT setexpression {
                 $$ = newUnaryOp(DEFAULT, $2);}
            | ORDERED { $$ = newUnaryOp(ORDERED, NULL);}
            ;
paramattributes_opt : /* empty */ { $$ = NULL;}
                     | paramattributes {$$ = $1;}
                     ;

paramattributes: paramattribute {
                 if ($1==NULL) {$$ = NULL;}
		   else{$$ = newUnaryOp(COMMA, $1);}}
               | paramattributes COMMA paramattribute {
		 if ($3==NULL){
		   $$ = $1;
		 }else{
		   if ($1==NULL){
		     $$ = newUnaryOp(COMMA, $3);
		   }else{
		     $$ = addItemToListNew($1, $3);
		   }
		 }
	       }
	       ;

paramattribute: BINARY {$$ = newUnaryOp(BINARY, NULL);}
              | INTEGER {$$ = newUnaryOp(INTEGER, NULL);}
              | SYMBOLIC {$$ = newUnaryOp(SYMBOLIC, NULL);}
              | relop expr  {$$ = newUnaryOp($1, $2);}
              | IN setexpression {$$ = newUnaryOp(IN, $2);}
              | ASSIGN expr {$$ = newUnaryOp(ASSIGN, $2);}
              | DEFAULT expr {$$ = newUnaryOp(DEFAULT, $2);}
              ;

stochattr_opt: /* empty */ {$$ = NULL;}
	      | DETERMINISTIC {
	           // check that this is in a stochastic model
    	           if (!is_stoch_model){ 
		     printf("Syntax Error: keyword 'DETERMINISTIC' can only be used in stochastic blocks\n");
		     exit(1);
		   }
		   is_deterministic_loc = true;
		   $$ = NULL;
	        }
              | STAGES setexpression {
	           // check that this is in a stochastic model
    	           if (!is_stoch_model){ 
		     printf("Syntax Error: keyword 'STAGES' can only be used in stochastic blocks\n");
		     exit(1);
		   }
  		  $$ = NULL;
		  stages_loc = $2;
	        }
              ;

varattributes_opt: /* empty */ {$$=NULL;}
                 | varattributes {$$ = $1;}
                 ;


varattributes: varattribute {
                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
             | varattributes COMMA varattribute{
 	          $$ = addItemToListOrCreate(COMMA, $1, $3);
	     }
             ;


/* FIXME: what to do about the ID in the last rule ? */
varattribute: BINARY {$$ = newUnaryOp(BINARY, NULL);}
            | INTEGER {$$ = newUnaryOp(INTEGER, NULL);}
            | SYMBOLIC {$$ = newUnaryOp(SYMBOLIC, NULL);}
            | LE expr {$$ = newUnaryOp(LE, $2);}
            | GE expr {$$ = newUnaryOp(GE, $2);}
            | DEFINED expr {$$ = newUnaryOp(DEFINED, $2);}
            | ASSIGN expr {$$ = newUnaryOp(ASSIGN, $2);}
            | DEFAULT expr {$$ = newUnaryOp(DEFAULT, $2);}
	      //| COEFF indexing_opt constraint expr
	      //| COVER indexing_opt constraint expr
	      //| OBJ indexing_opt objective expr
            | IN setexpression {$$ = newUnaryOp(IN, $2);}
            | SUFFIX ID expr {$$ = newUnaryOp(SUFFIX, $3);}
            ;

/* this is anything that evaluates to a set */
setexpression: LBRACE expr_list RBRACE  {$$ = newUnaryOp(LBRACE, $2);}
             | identifier    /* already defined identifier */ 
//             | indexing
             | setexpression CROSS setexpression {
	       $$ = newBinOp(CROSS, $1, $3);}
             | setexpression DIFF setexpression {
	       $$ = newBinOp(DIFF, $1, $3);}
             | LBRACKET setexpression RBRACKET {
               $$ = $2;}
             ;

/* Identifier is any quotation of a predefined object:
    RoutComm[j].Flow[k-3*j, k]#
   An iditem is simply a tree of opNodes that serve as an identifier.
   An 'identifer' is an opNode of type IDREF or IDREFM
*/
identifier: iditem {
             /* this is a simple identifier in global context */
             $$ = find_var_ref_in_context(current_model, $1);
            }
          | identifier DOT iditem{
	    /* identifier sets the context for the iditem:
	       The result of this is either a context setting or a
	       complete description of a variable.

	       Can implement this by simply adding context and argument lists
	    
	       A variable reference should be represented internally as a
	       pointer to the referenced object in the model list
	       and a pointer to the list of arguments

	       This can be represented as a opNode with
	       ->opCode = ID;
	       ->nval = # of arguments
	       ->values[0] = pointer to entity in model list
	       ->values[1 - n] = arguments 

	       CONTEXT: iditems can be interpreted in two different contexts
	        1) is the global context (i.e. referring from the model
		   part that is currently defined)
                2) is a local context that can be set by preceeding bits
		   of a dot'd expression. If a dot'd expression is 
		   parsed the flag 'local_context' should be set and 
		   'local_context' should be set to the current local
		   context. 
                a context is epressed as a pointer to a model entity

	    */
	    
	    /* identifier sets the context for the idem */
	    /* this only works if the identifier is actually a reference 
	       to a submodel */
	    opNode *onm = $1;
 	      void **newvalues;
	      int i;

	      if ($1->opCode!=IDREFM){
		printf("Attempting to use dot specifier for something not an");
		char *tmp1 = print_opNode($1);
		printf(" object:\n %s\n", tmp1);
		free(tmp1);
		exit(1);
	      }
	      local_context = (AmplModel*)(((opNodeIDREF*)$1)->ref)->other;

	      char *tmp1 = print_opNode($1);
	      char *tmp2 = print_opNode($3);
	      printf("Trying to merge \n identifier %s", tmp1);
	      printf(" and iditem %s\n", tmp2);
	      free(tmp1);
	      free(tmp2);
	      $$ = find_var_ref_in_context(local_context, $3);

	      /* merge argument lists */
//	      newvalues = (void **)calloc($1->nval+$$->nval+1,sizeof(void *));
//	      for(i=0;i<$1->nval;i++)
//		newvalues[i+1] = $1->values[i+1];
//	      for(i=0;i<$$->nval;i++)
//		newvalues[$1->nval+i+1] = $$->values[i+1];
//	      newvalues[0] = $$->values[0];
//	      $$->nval += $1->nval;
	      newvalues = (void **)calloc($1->nval+$$->nval,sizeof(void *));
	      for(i=0;i<$1->nval;i++)
		newvalues[i] = $1->values[i];
	      for(i=0;i<$$->nval;i++)
		newvalues[$1->nval+i] = $$->values[i];
	      $$->nval += $1->nval;
	      free($$->values);
	      $$->values = newvalues;
	      
	    }
          ;




iditem: ID {                               /* simple identifier */
          $$=newUnaryOp(ID, $1);}
      | ID LSBRACKET expr_list RSBRACKET { /* subscripted id'fier */
	  printf("%s\n", print_opNodesymb($3));
	  $$ = newBinOp(LSBRACKET, newUnaryOp(ID,$1), $3);
	  //printf("%s\n", print_opNodesymb($$));
        }
      | ID LBRACKET INT_VAL SEMICOLON expr_list RBRACKET {
 	  // This is of the type xh(-1,i) which is xh[i] at a previous stage
	  // the ancestor information is conveyed by an ID opNode with 
          // two arguments, where the second argument is the ancestor
	  // $3 is (long int*) => change its sign
	  *$3 = -(*$3);
	  opNode *nd = newBinOp(ID, $1, $3);
	  $$ = newBinOp(LSBRACKET, nd, $5);
        }      
      ;

/* expr_list: is a comma separated list of expr's */
/* used as argument list to functions 
   RETURNS: 
   *opNode of type COMMA representing a linked list of items
*/

expr_list: expr {
  //              indexNode *ixn = newIndexNode($1); 
  //             $$ = newBinOp(COMMA, ixn, ixn); /* set up a list */
               $$ = newUnaryOp(COMMA, $1);
           }
         | expr_list COMMA expr {      /* add item to list */
	   /* epxr_list could be a simple node or a comma separated list (CSL)
	      already 
	      - if it is a simple node, need to start a comma separated list
	      - if it is a CSL need to add an item to it
	   */
	   //printf("join nodes >%s< >%s<\n",
	   //	  print_opNode($1),print_opNode($3));
	   assert($1->opCode==COMMA);
 	   //if ($1->opCode==COMMA){
	     /* is CSL already => add item to it */
	     $$ = addItemToListNew($1, $3);
	     //}else{
	     /* start new CSL */
	     //printf("Start new CSL\n");
	     ////indexNode *ixn = newIndexNode($1); 
	     ////opNode *tmp = newBinOp(COMMA, ixn, ixn); /* set up a list */
	     ////tmp->nval = 1;
	     ////$$ = addItemToList(tmp, $3);
	     //$$ = newBinOp(COMMA, $1, $3);
	     //}
	 }
         ;

expr: value
    | LBRACKET expr_list RBRACKET {$$ = newUnaryOp(LBRACKET, $2);}
    | expr '+' expr { $$ = newBinOp('+', $1, $3); }
    | expr '-' expr { $$ = newBinOp('-', $1, $3); }
    | '-' expr { $$ = newUnaryOp('-', $2); }
    | expr '*' expr { $$ = newBinOp('*', $1, $3); }
    | expr '/' expr { $$ = newBinOp('/', $1, $3); }
    | expr POWER expr { $$ = newBinOp(POWER, $1, $3); }
    | expr ELLIPSE expr { $$ = newBinOp(ELLIPSE, $1, $3); }
    | expr LOGICAL_OR expr { $$ = newBinOp(LOGICAL_OR, $1, $3); }
    | expr LOGICAL_AND expr { $$ = newBinOp(LOGICAL_AND, $1, $3); }
    | '!' expr { $$ = newUnaryOp('!', $2) };
    | reduction_op indexing {add_indexing($2);} expr { 
      /* reduction operator: do we need to keep track of the ID of the
	 dummy variable(s)? */
      $$ = newBinOp((int)$1, $2, $4);
      rem_indexing($2);}
    | IF lexpr THEN expr {
	$$ = newBinOp(IF, $2, $4);}
    | IF lexpr THEN expr ELSE expr {
	$$ = newTertOp(IF, $2, $4, $6);}
    | FIRST LBRACKET setexpression RBRACKET {
        $$ = newUnaryOp(FIRST, $3);}
    | LAST LBRACKET setexpression RBRACKET {
        $$ = newUnaryOp(LAST, $3);}
    | EXPECTATION LBRACKET expr_list RBRACKET { 
      //$$ = newUnaryOp(EXPECTATION, newUnaryOp(LBRACKET, $3));}
      $$ = newUnaryOp(EXPECTATION, $3);}
    | func LBRACKET expr_list RBRACKET { /* function definition */
         $$ = newUnaryOp($1, newUnaryOp(LBRACKET, $3));}
    ;

func : ORD {$$=ORD;}
     | CARD {$$=CARD;}
     ;

reduction_op: SUM {$$=SUM;}
            | MAX {$$=MAX;}
            | MIN {$$=MIN;}
            | PROD {$$=PROD;}
            ;

value: INT_VAL {
  /* not entirly sure what is returned here as $1 */
  // Aparently a pointer to long int
          $$=newUnaryOp(INT_VAL, $1);
	  //$$ = (opNode *) malloc(sizeof(opNode));
	  //$$->opCode = INT_VAL;
	  //$$->values = (void **) malloc(1*sizeof(void *));
	  //$$->values[0] = (int *) malloc(sizeof(int));
	  //*((int *) $$->values[0]) = $1;
       }
     | FLOAT_VAL { 
         $$=newUnaryOp(FLOAT_VAL, $1);
       //$$ = (opNode *) malloc(sizeof(opNode));
       //$$->opCode = FLOAT_VAL;
       //$$->values = (void **) malloc(1*sizeof(void *));
       //$$->values[0] = (double *) malloc(sizeof(double));
       //*((double *) $$->values[0]) = $1;
       }
     | identifier { 
          $$=newUnaryOp(0, $1);
       //$$ = (opNode *) malloc(sizeof(opNode));
       //  $$->opCode = ID;
       //  $$->values = (void **) malloc(1*sizeof(void *));
       //  $$->values[0] = (void *) $1;
       }
     | INFINITY { 
          $$ = (opNode *) malloc(sizeof(opNode));
          $$->opCode = INFINITY;
          $$->values = NULL;
       }
     | STAGE { 
          $$ = new opNode();
	  $$->opCode = STAGE;
	  $$->nval = 0;
       }
     | NODE { 
          $$ = new opNode();
	  $$->opCode = NODE;
	  $$->nval = 0;
       }
     ;

/* ----------------------------------------------------------------------------
 stuff for the data file reader to follow
---------------------------------------------------------------------------- */
//data_statements: /* empty */
//          | data_statements data_statement 
//          ;
//
//data_statement: data_paramdef SEMICOLON
//              | data_setdef SEMICOLON
//              ;
//
//data_setdef: SET ID ASSIGN setelements
//
//setelements: /* empty */
//           | setelements setelement
//           ;
//
//setelement: ID
//         
//data_paramdef: PARAM ID ASSIGN valuelist
//
//valuelist: value
//         | valuelist value
//         ;
%%

void yyerror(char *s) {
  //fprintf(stderr, "%s on line %i\n", s, yylineno);
  fprintf(stderr, "%s\n", s);
}


/* ----------------------------------------------------------------------------
yywrap
---------------------------------------------------------------------------- */
/* not sure if this is correct, found this somewhere on the internet
   should open the data file and somehow tell the parser to carry on 
   reading in "data mode"

 */
int yywrap(void) {
  return 1;
}

void analyseOptions(int argc, char **argv){
  int i;
  int found =0;
  for (i=1;i<argc;i++){
    if (strcmp(argv[i], "-d")==0){
      yydebug = 1;
    }else{
      if (found==0){
	// first proper argument is the model file to read
	modelfilename = argv[i];
	found++;
      }else{
	// next one is data file
	datafilename = argv[i];
      }
    }
  }
  // now echo the options
  if (yydebug==1){
    printf("OPTIONS: debug mode\n");
  }
  if (modelfilename){
    printf("OPTIONS: model file: %s\n",modelfilename);
  }else{
    printf("OPTIONS: read model from stdout\n");
  }
  if (datafilename){
    printf("OPTIONS: data file: %s\n",datafilename);
  }else{
    printf("OPTIONS: read data from 'global.dat'\n");
  }
  return;
}

/* ----------------------------------------------------------------------------
main
---------------------------------------------------------------------------- */
int main(int argc, char **argv) {
  int errcode;
  modelfilename = NULL;
  datafilename = NULL;

  analyseOptions(argc, argv);
  if (modelfilename){
    yyin = fopen(modelfilename, "r");
    if (yyin==NULL){
      printf("ERROR: file '%s' not found\n",modelfilename);
      exit(1);
    }
  }
  
  /* set up global symbol list here */
   symb_entry **sht = (symb_entry**)calloc(N_HASH, sizeof(symb_entry*));

   /* setup the root of the model tree */
   //AmplModel::root = (AmplModel*)calloc(1, sizeof(AmplModel));
   AmplModel::root = new AmplModel;
   current_model = AmplModel::root;
   current_model->symb_hash_table = sht;
   current_model->name = (char *)&("root");
   current_model->parent = NULL;
   current_model->setGlobalName();
   is_stoch_model = false;
   is_deterministic_loc = false;
   stages_loc = NULL;
   is_deterministic_glo = false;
   stages_glo = NULL;

   errcode = yyparse();
   if (errcode!=0){
     printf("yyparse returns %d\n",errcode);
     exit(1);
   }

   if (datafilename){
     fclose(yyin);
     yyin = fopen(datafilename,"r");
     if (yyin==NULL){
       printf("ERROR: Data file '%s' not found\n",datafilename);
       exit(1);
     }
     
     parse_data(current_model, datafilename);
     
   }

   do_stuff(current_model);

   return 0;
}

/* ----------------------------------------------------------------------------
begin_model
---------------------------------------------------------------------------- */
void
begin_model(char *name, opNode *indexing) {
  AmplModel *new_mod = new AmplModel;
  symb_entry **sht = (symb_entry**)calloc(N_HASH, sizeof(symb_entry*));
  model_comp *newmc;
  
  printf("Start Model: %s\n",name);
  new_mod->symb_hash_table = sht;
  new_mod->name = strdup(name);

  /* FIXME: include attrib in definition */
  newmc = new model_comp(name, TMODEL, indexing, NULL);
  newmc->other = new_mod;

  new_mod->node = newmc;            /* add pointer-to-node to the model */
  addCompToModel(current_model, newmc);	
 
  new_mod->setGlobalName();	 
  /* and change current model */
  current_model = new_mod;
}

/* ----------------------------------------------------------------------------
begin_smodel
---------------------------------------------------------------------------- */
void
begin_smodel(char *name, opNode *indexing, opNode *stochsets) {
  StochModel *new_mod;
  symb_entry **sht = (symb_entry**)calloc(N_HASH, sizeof(symb_entry*));
  model_comp *newmc;
  
  if (stochsets->opCode!=COMMA || stochsets->nval!=4){
    printf("Syntax error in Stochastic Block definition: \n");
    printf(" 'USING' needs 4 parameters \n");
    exit(1);
  }

  printf("Start Stochastic Model: %s\n",name);

  new_mod = new StochModel((opNode*)stochsets->values[0], // stages
			   (opNode*)stochsets->values[1], // nodes
			   (opNode*)stochsets->values[2], // anc
			   (opNode*)stochsets->values[3], // prob
			   current_model); 

  new_mod->symb_hash_table = sht;
  new_mod->name = strdup(name);
  
  /* Fixme: include attrib in definition */
  newmc = new model_comp(name, TMODEL, indexing, NULL);
  newmc->other = new_mod;

  new_mod->node = newmc;            /* add pointer-to-node to the model */
  addCompToModel(current_model, newmc);
 
  new_mod->setGlobalName();	 
  /* and change current model */
  current_model = new_mod;
  is_stoch_model = true;
}

/* ----------------------------------------------------------------------------
end_model
---------------------------------------------------------------------------- */
void
end_model(){
  current_model = current_model->parent;
}
/* ----------------------------------------------------------------------------
end_smodel
---------------------------------------------------------------------------- */
void
end_smodel(){
  // current_model is a StochModel -> convert this into a tree a FlatModels

  // this is the model_comp pointing to the StochModel
  model_comp *mc = current_model->node; 
  
  // point that to the expanded flat model tree
  mc->other = ((StochModel*)current_model)->expandToFlatModel();

  // and change the name of the model_comp of this model to the name of the 
  // new (AmplModel) model. 
  // (this is a concatenation of the StochModel name and the name of the 
  // first stage)
  mc->id = strdup(((StochModel*)mc->other)->name);

  // and go back to the parent 
  current_model = current_model->parent;
  is_stoch_model = false;
}

/* ----------------------------------------------------------------------------
add_set_to_model
---------------------------------------------------------------------------- */
void
add_set_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc;
  if (is_stoch_model){
    newmc = new StochModelComp(id, TSET, indx, attrib);
  }else{
    newmc = new model_comp(id, TSET, indx, attrib);
  }
  addCompToModel(current_model, newmc);
  if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
}

/* ----------------------------------------------------------------------------
add_obj_to_model
---------------------------------------------------------------------------- */
void
add_obj_to_model(int token, char *id, opNode *indx, opNode *attrib){
  model_comp *newmc;
  if (is_stoch_model){
    newmc = new StochModelComp(id, TMIN, indx, attrib);
  }else{
    newmc = new model_comp(id, TMIN, indx, attrib);
  }
  if (token==MAXIMIZE) newmc->type = TMAX;
  //newmc->ismin = (token==MINIMIZE);

  addCompToModel(current_model, newmc);
  if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

}

/* ----------------------------------------------------------------------------
add_cons_to_model
---------------------------------------------------------------------------- */
void
add_cons_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc;
  if (is_stoch_model){
    newmc = new StochModelComp(id, TCON, indx, attrib)	;
  }else{
    newmc = new model_comp(id, TCON, indx, attrib)	;
  }
  addCompToModel(current_model, newmc);
  if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

  /*
  if (current_model->cons==NULL){
    current_model->cons = newmc;
  }else{
    model_comp *last = current_model->cons;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_cons++;
  */
}
/* ----------------------------------------------------------------------------
add_var_to_model
---------------------------------------------------------------------------- */
void
add_var_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc;
  if (is_stoch_model){
    newmc = new StochModelComp(id, TVAR, indx, attrib);
  }else{
    newmc = new model_comp(id, TVAR, indx, attrib);
  }
  addCompToModel(current_model, newmc);
  if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
}


/* ----------------------------------------------------------------------------
add_param_to_model
---------------------------------------------------------------------------- */
void
add_param_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc;
  if (is_stoch_model){
    newmc = new StochModelComp(id, TPARAM, indx, attrib);
  }else{
    newmc = new model_comp(id, TPARAM, indx, attrib);
  }
  addCompToModel(current_model, newmc);
  if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
    
  /*
  if (current_model->params==NULL){
    current_model->params = newmc;
  }else{
    model_comp *last = current_model->params;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_params++;
  */
}

/* ----------------------------------------------------------------------------
 makeListOfDependencies
---------------------------------------------------------------------------- */
/* this routine makes a list of dependencies of one object on other 
   objects:

   it first scans through the indexing part identifying all dummy
   variables.

   all entities referenced in either the indexing part or attribute part are
   identified (i.e. their entry_atom is found) and a list of them is generated


*/

void
makeListOfDependencies(opNode *indx, opNode *attrib)
{
  /* identify all dummy variables from the indexing part */
  /* => is it correct to assume that anything to the left of keyword 'IN'
        is a dummy variable ? */

  opNode *tmpnode;
  int ndummy;
  char **ldummy;
  int nlist;     /* length of list */


  tmpnode = findKeywordinTree(indx, IN);
  
  /* okay: count number of dummy variables */
  ndummy = countKeywordinTree((opNode*)tmpnode->values[0], ID);
  ldummy = (char **)calloc(ndummy, sizeof(char*));
  /* and make a list of dummy variables */
  findIDinTreeAndAddToList((opNode*)tmpnode->values[0], ldummy, &nlist);

  /* and make a list of all variables */
  findIDinTreeAndAddToList(indx, ldummy, &nlist);
  findIDinTreeAndAddToList(attrib, ldummy, &nlist);
  
  /* FIXME: 
    - add pointer to counter to argument list above 
    - ldummy array needs to be allocated with enough space 
    - the last two adding ID calls need to try to find the
       added entity in the current hash table and add the atom_entry to the
       list (rather than just the name as is at the moment)
       => ldummy should be a var_entry *list
    - the whole thing needs to be called from outside
      with every c/s, var, etc definition statement
  */
}

/* ----------------------------------------------------------------------------
findKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

opNode *
findKeywordinTree(opNode *root, int oc)
{
  opNode *res1, *res2;;
  if (root->opCode==oc) return root;
  
  if (root->nval==0) return NULL;
  res1 = findKeywordinTree((opNode*)root->values[0], oc);
  if (root->nval==1) return res1;
  res2 = findKeywordinTree((opNode*)root->values[1], oc);
  if (res1 && res2) {
    printf("Found keyword %d at least twice in %s\n",oc, print_opNode(root));
    exit(1);
  }
  if (res1) {
    return res1;
  }else{
    return res2;
  }
}

/* ----------------------------------------------------------------------------
countKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and counts the number of keyword 'oc'
   nodes in the tree */


int
countKeywordinTree(opNode *root, int oc)
{
  int i, ret = 0;
  if (root->opCode==oc) return 1;
  
  for(i=0;i<root->nval;i++){
    ret += countKeywordinTree((opNode*)root->values[i], oc);
  }
  return ret;
}

/* ----------------------------------------------------------------------------
findIDinTreeAndAddToList(tmpnode->values[0], ldummy);
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

void
findIDinTreeAndAddToList(opNode *node, char  **list, int *nlist)
{
  int i;

  if (node->opCode==ID){
    int found = 0;
    /* add the variable name to the list */
    /* should check that the name is not on the list already */
    printf("Consider to add name %s to list\n",node->values[0]);
    for(i=0;i<(*nlist);i++){
      if (strcmp((const char*)node->values[0], list[i])==0)
	found = 1;
    }

    if (found==0){
      list[*nlist] = (char*)node->values[0];
      (*nlist)++;
    }
    return;
  }
  for (i=0;i<node->nval;i++){
    findIDinTreeAndAddToList((opNode*)node->values[i], list, nlist);
  }
  
}

/* ---------------------------------------------------------------------------
find_var_ref_in_context
---------------------------------------------------------------------------- */
/** This routine does the work of putting together dot'd variable names
 *  'root' is a opNode of type ID that points to the left hand part
 *  of the dot'd expression parsed so far. 'ref' is the new part that
 *  should be added.
 *
 * @param ref A pointer to an expression that evaluates to a model_comp
 *            this can be given by an ID a dotted expression ID.ID
 *            or a reference to a parent stage (in StochProg) such as 
 *            ID(-1;...).
 *            It can also carry an indexing expressinon ID[.,.,.] in
 *            which case the indexing is attached to the returned IDREF node
 * @param context A pointer to the current AmplModel that defines the scope
 *                in which the ID expressions should be resolved
 * @return An opNode of type IDREF that points to the correct model_comp
 * @bug Should return an opNodeIDREF* 
 *
 *  An opNode of type IDREF looks like this
 *       ->opCode = IDREF;
 *       ->nval = # of arguments
 *       ->values[0] = pointer to entity in model list
 *       ->values[1 - n] = arguments 
 */
opNode*
find_var_ref_in_context(AmplModel *context, opNode *ref)
{
  /* 'ref' is an opNode representing an iditem. 
     This can be either
     - a ID node where values[0] simply points to a name
     - an ID node which is actually opNodeID and has stochparent set
     - a LSBRACKET node, where values[0] is ID and values[1] is CSL
     in the second case the CSL should be added as further arguments
     to the resulting IDREF node

  */
  
  /* returns: pointer 
   */
  int i;
  model_comp *thismc;
  opNode *tmp, *idNode, *argNode;
  AmplModel *thism;
  opNodeIDREF *ret;
  int stochparent=0;

  char *name;
  /* and now scan through the whole of the local context to see if we 
     find any matches */
  /* the local context is 
      - all vars
      - all constraints
      - all objectives
      - all sets
      - all parameters
      - all submodels
      - all temporary variables (this list needs to be set up somewhere)
  */
  
  // split the expression 'ref' into an id part and an argument list
  printf("find_var_ref_in_context: %s\n",ref->print());

  if (ref->opCode==ID){
    idNode = ref;
    argNode = NULL;
  }else{
    assert(ref->opCode==LSBRACKET||ref->opCode==LBRACKET);
    idNode = (opNode*)ref->values[0];
    argNode = (opNode*)ref->values[1];
    assert(idNode->opCode==ID);
    assert(argNode->opCode==COMMA);
  }

  // Test if this ID node is actually of type opNodeID and if so remember
  // the value of stochparent
  {
    if (idNode->nval==2){
      // there is an extra argument, which is the stochparent
      stochparent = *(int*)(idNode->values[1]);
    }
  }

  name = (char*)idNode->values[0];
  printf("--> search for matches of %s\n",name);
 
  // see if this matches a dummy variable
  tmp = find_var_ref_in_indexing(name);
  if (tmp) {
    char *tmp1 = print_opNode(tmp);
    printf("%s is matched by dummy var in %s\n",name, tmp1);
    free(tmp1);
    return ref;
  }

  // try to find a match in the local context
  ret = find_var_ref_in_context_(context, idNode);

  if (argNode){
    char *tmp1 = print_opNode(argNode);
    printf("Adding argument list to node: %s\n",tmp1);
    free(tmp1);
    free(idNode->values);
    ret->values = argNode->values;
    ret->nval = argNode->nval;
    if (ref->opCode==LBRACKET){
      // this is old code to deal with ancestor(1).ID declarations. To go
      printf("Executing old code to deal with ancestor(1).ID declarations\n");
      exit(1);

      // This is a reference indexed by '(..)'. In this case we are in
      // a stoch block and the first argument refers to the stage
      //      ret->stochrecourse = (opNode*)ret->values[0];
      //for(int i=1;i<ret->nval;i++){
      //ret->values[i-1] = ret->values[i];
      //}
      //ret->nval--;
    }
    argNode->values=NULL;
    argNode->nval = 0;
  } else {
    ret->nval = 0;
  }
  
  ret->stochparent = stochparent;
  return ret;

}

opNodeIDREF*
find_var_ref_in_context_(AmplModel *context, opNode *ref)
{
  int i;
  model_comp *thismc;
  opNode *tmp;
  AmplModel *thism;
  char *name = (char*)ref->values[0];
  opNodeIDREF *ret;		
  
  for(list<model_comp*>::iterator p = context->comps.begin();
	  p!=context->comps.end();p++){
    thismc = *p;
    if (strcmp(name, thismc->id)==0){
      /* this is a match */
      char *tmp1 = print_opNode(thismc->indexing);
      char *tmp2 = print_opNode(thismc->attributes);
      printf("Found Match: %s refers to %s\n",name, nameTypes[thismc->type]);
      printf("    %s\n",thismc->id);
      printf("       %s\n", tmp1);
      printf("       %s\n", tmp2);
      free(tmp1);
      free(tmp2);

      ret = new opNodeIDREF();
      ret->ref = thismc;
      ret->opCode = IDREF;
      if (thismc->type==TMODEL){
	ret->opCode = IDREFM;
      }
      return ret;
    }
    //thismc = thismc->next;
  }

  
  //thismc = context->vars;
  //for(i=0;i<context->n_vars;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to variable\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->cons;
  //for(i=0;i<context->n_cons;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* thismc is a match */
  //    printf("Found Match: %s refers to constraint\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->sets;
  //for(i=0;i<context->n_sets;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to set\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->params;
  //for(i=0;i<context->n_params;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to parameter\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thism = context->submodels;
  //for(i=0;i<context->n_submodels;i++){
  //  if (strcmp(name, thism->name)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to submodel\n",name);
  //    printf("    %s\n",thism->name);
  //    //printf("       %s\n",print_opNode(thism->indexing));
  //    //printf("       %s\n",print_opNode(this->attributes));
  //    ref->values[0] = (void*)thism;
  //    ref->opCode = IDREFM;
  //    return ref;
  //  }
  //  thism = thism->next;
  //}

  /* need also to look through parent model */
  if (context->parent){
    opNodeIDREF *match = find_var_ref_in_context_(context->parent, ref);
    return match;
  }

  /* need also to look through list of local variables */

  printf("Could not find ref %s in context\n",name);
  exit(1);

}


/* ---------------------------------------------------------------------------
find_var_ref_in_indexing
---------------------------------------------------------------------------- */
/* scan through the current set of active indexing expressions and see if
   any of them define the dummy variable  given by 'name' 

   IN: 
    char *name                 the name of identifier to look for
    
    int n_indexing             the currently active indexing expressions
    opNode *list_of_indexing
   RETURN:
    The Indexing expression in which the name occurs 
    (or NULL if there is no match)
                                                                      */

opNode *
find_var_ref_in_indexing(char *name)
{
  int i;
  opNodeIx *tmp;
  opNode *ret = NULL;

  for(i=0;i<n_indexing;i++){
    /* have a look at all the indexing expressions */
    /* an indexing expression is a '{' node followed by a 'Comma' node */
    tmp = list_of_indexing[i];
    if (tmp!=NULL){
      tmp->splitExpression();
      ret = tmp->hasDummyVar(name);
      if (ret) return ret;
 		
#if 0
    assert(tmp->opCode==LBRACE);
    tmp = (opNode*)tmp->values[0];
    if (tmp->opCode==COLON) tmp = (opNode*)tmp->values[0];
    /* this should now be a comma separated list */
    if (tmp->opCode==COMMA){
      for(j=0;j<tmp->nval;j++){
	tmp2 = findKeywordinTree((opNode*)tmp->values[j], IN);
	/* everything to the left of IN is a dummy variables */
	if (tmp2){
	  tmp2 = (opNode*)tmp2->values[0];
	  assert(tmp2->opCode==ID);
	  printf("Found dummy variable: %s\n",tmp2->values[0]);
	  if (strcmp(name, (const char*)tmp2->values[0])==0)
	    ret = (opNode*)tmp->values[j];
	  
	}
      }
    }else{
      /* if this is not a comma separated list, then look directly */
      char *tmpbuf1 = print_opNode(tmp);
      char *tmpbuf2 = print_opNodesymb(tmp);
      printf(">%s\n", tmpbuf1);
      printf(">%s\n", tmpbuf2);
      free(tmpbuf1);
      free(tmpbuf2);
      tmp2 = findKeywordinTree(tmp, IN);
      /* everything to the left of IN is a dummy variables */
      if (tmp2){
	tmp2 = (opNode*)tmp2->values[0];
	assert(tmp2->opCode==ID||tmp2->opCode==COMMA);
	printf("Found dummy variable: %s\n",tmp2->values[0]);
	if (strcmp(name, (const char*)tmp2->values[0])==0)
	  ret = tmp;
      }
    }
#endif
    }
  }
  return ret;
}

/* ------------------------------------------------------------------------
add_indexing/rem_indexing
-------------------------------------------------------------------------- */
void 
add_indexing(opNodeIx *indexing){
  char *tmp1 = print_opNode(indexing);
  char *tmp2 = print_opNodesymb(indexing);
  list_of_indexing[n_indexing] = indexing;
  printf("add indexing expression to list: %s\n", tmp1);
  printf("Symbolic indexing: %s\n", tmp2);
  printf("length of indexing now: %d\n",n_indexing+1);
  free(tmp1);
  free(tmp2);
  n_indexing++;
}

void
rem_indexing(opNodeIx *indexing){
  if (indexing){
    assert(indexing==list_of_indexing[n_indexing-1]);
    char *tmp = print_opNode(indexing);
    printf("rem indexing expression to list: %s\n", tmp);
    free(tmp);
  }
  printf("length of indexing now: %d\n",n_indexing-1);
  n_indexing--;
}

/* ---------------------------------------------------------------------------
Stochastic model helper functions
---------------------------------------------------------------------------- */
void 
addStochInfo(StochModelComp *newmc)
{
  newmc->is_deterministic = is_deterministic_loc | is_deterministic_glo;
  if (stages_loc){
    newmc->stageset = stages_loc;
  }else{
    newmc->stageset = stages_glo;
  }
  newmc->stochmodel = static_cast<StochModel*>(newmc->model);	
  if (newmc->stochmodel==NULL){
    printf("addStochInfo: dynamic cast failed!\n");
    exit(1);
  }
  stages_loc = NULL;
  is_deterministic_loc = false;
}
