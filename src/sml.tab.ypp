%debug

%{
   #define YYERROR_VERBOSE
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <assert.h>
   #include <sys/stat.h>
   #include <iostream>
   #include "nodes.h"
   #include "GlobalVariables.h"
   #include "StochModel.h"
   #include "StochModelComp.h"
   #include "symtab.h"
   #include "backend.h"
   #include "SetNode.h"
   #include "AmplModel.h"

   void add_indexing(SyntaxNodeIx *indexing);
   void rem_indexing(SyntaxNodeIx *indexing);
   void begin_model(char *name, SyntaxNode *indexing);
   void end_model();
   ModelComp *add_set_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib);
   ModelComp *add_obj_to_model(int token, char *id, SyntaxNode *indx,
      SyntaxNode *attrib);

   extern int yylineno;
   int yylex(void);
   void yyerror(char *s);
   /* global variables */
   char *GlobalVariables::modelfilename = NULL;
   char *GlobalVariables::datafilename = NULL;
   char *GlobalVariables::amplcommand = "ampl";

   bool GlobalVariables::logParseModel = false;
   int GlobalVariables::prtLvl = 1;

   static AmplModel *current_model;    /* this is the model currently active */
                                       /* this is the GLOBAL context */
   static AmplModel *local_context;    /* this is the LOCAL context */
   SyntaxNodeIx *list_of_indexing[20];    /* list of currently applicable 
                                                indexing expressions */
   int n_indexing;
   /* ---------------- stochastic global variables:------------------------ */
   static bool is_stoch_model;      /* true if inside stochastic model def */
   /* these are set within entity definitions and reset at the end of them */
   static bool is_deterministic_loc;
   static SyntaxNode *stages_loc;
   /* these are set by global stocastic modifier commands */
   static bool is_deterministic_glo;
   static SyntaxNode *stages_glo;
   extern FILE *yyin;
   extern void parse_data(AmplModel *current_model, char *datafilename);

   ModelComp *add_cons_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib);
   ModelComp *add_param_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib);
   ModelComp *add_var_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib);
   void addStochInfo(StochModelComp *newmc);
   void createSubdirTmpIfNotExist(void);
%}

%union
{
  int optype;
  long *ival;
  double *fval;
  char *string;
  SyntaxNode *opPtr;
  SyntaxNodeIx *opPtrIx;
}

%type <string> cnstr
%type <opPtr> expr value  equation expr_list 
%type <opPtr> setattributes setattribute setattributes_opt
%type <opPtr> stochattr_opt
%type <opPtr> paramattributes_opt paramattributes paramattribute 
%type <opPtr> varattributes_opt varattributes varattribute 
//%type <opPtr> csattributes_opt csattributes csattribute 
%type <opPtr> setexpr_list lexpr 
%type <opPtr> setexpression identifier iditem setexpr_item dummy_member
%type <opPtr> commasepoptions optionlist
%type <opPtrIx> indexing indexing_opt
%type <optype> relop reduction_op func ubsetop bsetop

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITY COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE DOTDOT
%token NET_IN NET_OUT DIMEN ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED LOGICAL_OR LOGICAL_AND ELLIPSE
%token PUBLIC CORE DOT BEG TIMESTAGE RANDOM SUFFIX BLOCK IDREF IDREFM
%token SBLOCK USING DETERMINISTIC EXPECTATION STOCHASTIC STAGES
%token STAGE NODE ANCESTOR

%right ASSIGN
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NE
%left LT LE GT GE
%left '+' '-'
%left '*' '/'
%right POWER
%left '!'
%left ELLIPSE

%%
statements: /* empty */
          | statements statement 
          ;

block:   modelblock
     //| coreblock
     |   stochblock
     |   blockblock
     |   stageblock
     ;

modelblock: modelblockbegin statements modelblockend

/* a model command sets up a submodel of the current model */
modelblockbegin:  MODEL ID optionlist {begin_model((char *)$2, NULL);}
               |  MODEL MODELTYPE ID optionlist {begin_model((char*)$3, NULL);}
               ;

modelblockend: END MODEL {end_model();}

optionlist: /*empty */ {$$=NULL;}
          | LBRACKET commasepoptions RBRACKET {$$=$2;}
          ;

commasepoptions:  identifier {
                     $$ = new SyntaxNode(COMMA, $1);}
               |  commasepoptions COMMA identifier{
                     $$ = $1->push_back($3);
                  }
               ;
/* -------------------------------------------------------------------- 
  blockblock
------------------------------------------------------------------------- */
/* A blockblock is a block definition of the form

     block name{indexing}:
       statements
     end block;

which means that all the statements within the block are repeated over the
indexing expression 
*/

blockblock: blockblockbegin statements blockblockend

blockblockbegin:  BLOCK ID indexing_opt COLON {
                     add_indexing($3);
                     begin_model((char*)$2, $3);
                  }

blockblockend: END BLOCK SEMICOLON {
                  end_model();
                  rem_indexing(NULL);
               }
/* -------------------------------------------------------------------- 
  stochblock
------------------------------------------------------------------------- */
/* A stochblock is a block definition of the form

     [sblock/stochastic block] name{indexing} using (STAGES,NODES,ANC,PROB):
       statements
     end sblock;

where 
  STAGES: set of time stages 
  NODES: set of nodes in the tree
  ANC{NODES}: ancestor for every node
  PROB{NODES}: conditional probability of reaching this node from parent

  The whole block is repeated over all STAGES (actually over all NODES). 
  Entities marked 'deterministic' are only repeated over STAGES

--------------------------------------------------------------------
Logic of stochastic qualifiers: deterministic/stages:
 - if an sblock is started, then is_stoch_model is set to true
 - if an sblock is closed, then is_stoch_model is set to false
 - deterministc/stages are read in as attributes to param/set/var/etc defs
 - their value is stored in global variables stages/is_deterministic




*/

stochblock: sblockbegin statements sblockend
          | stochblockbegin statements stochblockend
          | sblockbeginbrace statements RBRACE {
               end_smodel();
               rem_indexing(NULL);
            }
          ;
    
/* FIXME: optionlist is of form '(ID COMMA ID ...)'
     need to call new SyntaxNode and addToListItem functions in the 
     processing of optionlist and its children */
stochblockbegin:  STOCHASTIC BLOCK ID indexing_opt USING optionlist COLON {
                     add_indexing($4);
                     begin_smodel((char*)$3, $4, $6);
                  }

sblockbegin:   SBLOCK ID indexing_opt USING optionlist COLON {
                  add_indexing($3);
                  begin_smodel((char*)$2, $3, $5);
               }
           |   BLOCK ID indexing_opt STOCHASTIC USING optionlist COLON {
                  add_indexing($3);
                  begin_smodel((char*)$2, $3, $6);
               }
           ;             

sblockbeginbrace: BLOCK ID indexing_opt STOCHASTIC USING optionlist COLON
                  LBRACE {
                     add_indexing($3);
                     begin_smodel((char*)$2, $3, $6);
                  }
           ;             

stochblockend: END STOCHASTIC BLOCK SEMICOLON {
                  end_model();
                  rem_indexing(NULL);
               }

sblockend:  END SBLOCK SEMICOLON {
               end_smodel();
               rem_indexing(NULL);
            }

/* -------------------------------------------------------------------- 
  stageblock
------------------------------------------------------------------------- */

stageblock: STAGE setexpression COLON {              
               if (!is_stoch_model) { 
                  cerr << "Syntax Error: keyword 'STAGES' can only be used in"
                     "stochastic blocks\n";
                  exit(1);
               }
               stages_glo = $2;
            } LBRACE statements RBRACE {
               stages_glo = NULL;
            }

//coreblock: BEG CORE statements END CORE

statement:  setdef SEMICOLON
         |  paramdef SEMICOLON
         |  vardef SEMICOLON
         |  cnstr SEMICOLON
         |  command SEMICOLON
         |  block
         |  INCLUDE ID SEMICOLON
         |  set_default COLON
         ;

set_default: TIMESTAGE INT_VAL
           ;

/* FIXME */
command: SOLVE
       | LET indexing identifier DEFINED expr
       ;

relop:   LE {$$=LE;}
     |   GE {$$=GE;}
     |   LT {$$=LT;}
     |   GT {$$=GT;}
     |   ASSIGN {$$=ASSIGN;}
     |   EQ {$$=EQ;}
     |   NE {$$=NE;}
     ;

equation: expr ASSIGN expr { $$ = new OpNode(ASSIGN, $1, $3); }
        | expr LT expr { $$ = new OpNode(LT, $1, $3); }
        | expr LE expr { $$ = new OpNode(LE, $1, $3); }
        | expr GT expr { $$ = new OpNode(GT, $1, $3); }
        | expr GE expr { $$ = new OpNode(GE, $1, $3); }
        | expr EQ expr { $$ = new OpNode(EQ, $1, $3); }
        ;

cnstr:   MAXIMIZE ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON expr {
            ModelComp *newmc = add_obj_to_model(MAXIMIZE, $2, $3, $7);     
            current_model->symbol_table.defineSymbol(SymbolTable::ST_OBJ, $2,
               newmc);
            if ($3) rem_indexing($3);
            $$=$2;
         }
     |   MINIMIZE ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON expr {
            ModelComp *newmc = add_obj_to_model(MINIMIZE, $2, $3, $7);
            current_model->symbol_table.defineSymbol(SymbolTable::ST_OBJ, $2,
               newmc); 
            if ($3) rem_indexing($3);
            $$=$2;
         }
     |   SUBJECTTO ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON equation { 
            ModelComp *newmc = add_cons_to_model($2, $3, $7);
            current_model->symbol_table.defineSymbol(SymbolTable::ST_CONS, $2,
               newmc); 
            if ($3) rem_indexing($3);
            $$=$2;
         }
     ;

//csattributes_opt: /* empty */ {$$=NULL;}
//                 | csattributes {$$ = $1;}
//                 ;


//csattributes: csattribute {
//                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
//             | csattributes COMMA csattribute{
//              $$ = addItemToListOrCreate(COMMA, $1, $3);
//        }
//             ;

//csattribute: STAGES setexpression {
//               $$ = NULL;
//          stages = $2;
//             }
//           ;

indexing_opt: /* empty */ {$$=NULL;}
            | indexing {$$=$1;}
            ;

indexing:   LBRACE setexpr_list COLON lexpr RBRACE {
               SyntaxNode *tmp = new SyntaxNode(LBRACE, new SyntaxNode(COLON, $2, $4));
               $$ = new SyntaxNodeIx(tmp);
               delete tmp;
            }
        |   LBRACE setexpr_list RBRACE {
               SyntaxNodeIx *tmp = new SyntaxNodeIx(new SyntaxNode(LBRACE, $2));
               $$=tmp;
            }
        ;

/* FIXME: ID IN setexpression defines a dummy variable (?)
   -> have this as a separate construct
   -> how to deal with dummy variables? */
setexpr_list:  setexpr_item
            |  setexpr_list COMMA setexpr_item{
                  if ($1->opCode==COMMA){
                     $$ = $1->push_back($3);
                  }else{
                     $$ = new ListNode(COMMA, (ListNode*)$1, $3);
                  }
               }
            ;

setexpr_item : setexpression
             | dummy_member IN setexpression{
                  $$ = new OpNode(IN, $1,$3);
               }
             ;

dummy_member : ID {$$=new IDNode($1);}
             | LBRACKET ID COMMA ID RBRACKET {
                  SyntaxNode *tmp = new SyntaxNode(LBRACKET, 
                     new SyntaxNode(COMMA, new IDNode($2), new IDNode($4)));
                  $$ = tmp;
               }
             ;

lexpr:   expr
     |   LBRACKET lexpr RBRACKET {
            $$ = new SyntaxNode(LBRACKET, $2); }
     |   equation
     ;

setdef:  SET ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt setattributes_opt {
            ModelComp *newmc = add_set_to_model($2, $3, $6);
            current_model->symbol_table.defineSymbol(SymbolTable::ST_SET, $2,
               newmc); 
            if (GlobalVariables::logParseModel) 
               cout << "$6 = " << $6 << "\n";
            if (GlobalVariables::logParseModel)
               cout << "$5 = " << $5 << "\n";
            if ($3) rem_indexing($3);
            //$$=$2; 
         }
      ;

/* qualifier can be public/random: is this redundant? */
paramdef:   qualifier PARAM ID indexing_opt {
               if ($4) add_indexing($4);
            } stochattr_opt paramattributes_opt {
               ModelComp *newmc = add_param_to_model($3, $4, $7);
               current_model->symbol_table.defineSymbol(
                  SymbolTable::ST_PARAM, $3, newmc); 
               if ($4) rem_indexing($4);
               //$$=$2; 
            }
        ;

vardef:  VAR ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt varattributes_opt {
            ModelComp *newmc = add_var_to_model($2, $3, $6);
            current_model->symbol_table.defineSymbol(SymbolTable::ST_VAR, $2,
               newmc); 
            if ($3) rem_indexing($3);
            //$$=$2; 
         }
      ;



qualifier:  /* empty */
         |  PUBLIC
         |  RANDOM
         ;

/* these are SET definitions */

setattributes_opt:   /* empty */ {$$=NULL;}
                 | setattributes {$$=$1;}
                 ;

setattributes: setattribute {$$=$1;}
             | setattributes setattribute {
                  if ($2==NULL){
                     $$ = $1;
                  }else{
                     if ($1==NULL){
                        $$ = new ListNode(' ', $2);
                     }else{
                        if ($1->opCode==' '){
                           $$ = $1->push_back($2);
                        }else{
                           $$ = new ListNode(' ', $1, $2);
                        }
                     }
                  }
               }
             ;

setattribute:  DIMEN INT_VAL {
                  $$ = new SyntaxNode(DIMEN, new ValueNode<long>(*$2));
               }
            |  WITHIN setexpression {
                  $$ = new SyntaxNode(WITHIN, $2);
               }
            | DEFINED setexpression {
                  $$ = new SyntaxNode(DEFINED, $2);
               }
            |  DEFAULT setexpression {
                  $$ = new SyntaxNode(DEFAULT, $2);
               }
            |  ORDERED { $$ = new SyntaxNode(ORDERED); }
            ;

paramattributes_opt: /* empty */ { $$ = NULL; }
                   | paramattributes { $$ = $1; }
                   ;

paramattributes:  paramattribute {
                     if ($1==NULL) {$$ = NULL;}
                     else{$$ = new ListNode(COMMA, $1);}
                  }
               |  paramattributes COMMA paramattribute {
                     if ($3==NULL){
                        $$ = $1;
                     }else{
                        if ($1==NULL){
                           $$ = new ListNode(COMMA, $3);
                        }else{
                           $$ = $1->push_back($3);
                        }
                     }
                  }
               ;

paramattribute:   BINARY {$$ = new SyntaxNode(BINARY);}
              |   INTEGER {$$ = new SyntaxNode(INTEGER);}
              |   SYMBOLIC {$$ = new SyntaxNode(SYMBOLIC);}
              |   relop expr {$$ = new OpNode($1, $2);}
              |   IN setexpression {$$ = new OpNode(IN, $2);}
              |   ASSIGN expr {$$ = new OpNode(ASSIGN, $2);}
              |   DEFAULT expr {$$ = new SyntaxNode(DEFAULT, $2);}
              ;

stochattr_opt: /* empty */ {$$ = NULL;}
             | DETERMINISTIC {
                  // check that this is in a stochastic model
                  if (!is_stoch_model){ 
                     cerr << "Syntax Error: keyword 'DETERMINISTIC' can only"
                        "be used in stochastic blocks\n";
                     exit(1);
                  }
                  is_deterministic_loc = true;
                  $$ = NULL;
               }
             | STAGES setexpression {
                  // check that this is in a stochastic model
                  if (!is_stoch_model){ 
                     cerr << "Syntax Error: keyword 'STAGES' can only be used"
                        "in stochastic blocks\n";
                     exit(1);
                  }
                  $$ = NULL;
                  stages_loc = $2;
               }
             ;

varattributes_opt:   /* empty */ {$$=NULL;}
                 |   varattributes {$$ = $1;}
                 ;


varattributes: varattribute {
                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
             | varattributes COMMA varattribute {
                  $$ = addItemToListOrCreate(COMMA, (ListNode*)$1, $3);
               }
             ;

/* FIXME: what to do about the ID in the last rule ? */
varattribute:  BINARY {$$ = new SyntaxNode(BINARY);}
            |  INTEGER {$$ = new SyntaxNode(INTEGER);}
            |  SYMBOLIC {$$ = new SyntaxNode(SYMBOLIC);}
            |  LE expr {$$ = new OpNode(LE, $2);}
            |  GE expr {$$ = new OpNode(GE, $2);}
            |  DEFINED expr {$$ = new SyntaxNode(DEFINED, $2);}
            |  ASSIGN expr {$$ = new OpNode(ASSIGN, $2);}
            |  DEFAULT expr {$$ = new SyntaxNode(DEFAULT, $2);}
         //| COEFF indexing_opt constraint expr
         //| COVER indexing_opt constraint expr
         //| OBJ indexing_opt objective expr
            |  IN setexpression {$$ = new OpNode(IN, $2);}
            |  SUFFIX ID expr {$$ = new SyntaxNode(SUFFIX, $3);}
            ;

/* this is anything that evaluates to a set */
setexpression: LBRACE expr_list RBRACE  {$$ = new ListSet($2);}
             | identifier    /* already defined identifier */ 
             | setexpression bsetop setexpression {
                  $$ = new CompositeSet($2, $1, $3);
               }
             | setexpression ubsetop setexpression {
                  $$ = new CompositeSet($2, $1, $3);
               }
             | ubsetop indexing setexpression {
                  cerr << "FIXME: ubsetop indexing setexpression\n";
                  exit(2);
               }
             | expr DOTDOT expr {
                  $$ = new SimpleSet($1, $3);
               }
             | SETOF indexing identifier {
                  cerr << "FIXME: SETOF\n";
                  exit(2);
               }
             //FIXME: | if lexpr then sexpr else sexpr
             | LBRACKET setexpression RBRACKET {
                  $$ = $2;
               }
             //FIXME: | interval
             //FIXME: | infinite-set
             //FIXME: | indexing
             ;

bsetop:  DIFF     { $$ = DIFF; }
      |  SYMDIFF  { $$ = SYMDIFF; }
      |  CROSS    { $$ = CROSS; }
      ;

ubsetop: UNION    { $$ = UNION; }
      |  INTER    { $$ = INTER; }
      ;
      

/* Identifier is any quotation of a predefined object:
    RoutComm[j].Flow[k-3*j, k]#
   An iditem is simply a tree of SyntaxNodes that serve as an identifier.
   An 'identifer' is an SyntaxNode of type IDREF or IDREFM
*/
identifier: iditem {
               /* this is a simple identifier in global context */
               $$ = find_var_ref_in_context(current_model, $1);
            }
          | identifier DOT iditem {
               /* identifier sets the context for the iditem:
                  The result of this is either a context setting or a
                  complete description of a variable.

                  Can implement this by simply adding context and argument lists
                
                  A variable reference should be represented internally as a
                  pointer to the referenced object in the model list
                  and a pointer to the list of arguments

                  This can be represented as a SyntaxNode with
                  ->opCode = ID;
                  ->nval = # of arguments
                  ->values[0] = pointer to entity in model list
                  ->values[1 - n] = arguments 

                  CONTEXT: iditems can be interpreted in two different contexts
                  1) is the global context (i.e. referring from the model
                     part that is currently defined)
                  2) is a local context that can be set by preceeding bits
                     of a dot'd expression. If a dot'd expression is 
                     parsed the flag 'local_context' should be set and 
                     'local_context' should be set to the current local
                     context. 
                  a context is expressed as a pointer to a model entity
               */
       
               /* identifier sets the context for the idem */
               /* this only works if the identifier is actually a reference 
                  to a submodel */

               if ($1->opCode!=IDREFM){
                  cerr << "Attempting to use dot specifier for something "
                     "not an object:\n " << *($1) << "\n";
                  exit(1);
               }
               local_context = (AmplModel*)(((SyntaxNodeIDREF*)$1)->ref)->other;

               if (GlobalVariables::logParseModel) {
                  cout << "Trying to merge \n identifier "<< *($1);
                  cout << " and iditem " << *($3) << "\n";
               }
               $$ = find_var_ref_in_context(local_context, $3);

               /* merge argument lists */
               $$->merge(*($1));
            }
          ;




iditem:  ID {                               /* simple identifier */
            $$=new IDNode($1);
         }
      |  ID LSBRACKET expr_list RSBRACKET { /* subscripted id'fier */
            if (GlobalVariables::logParseModel) 
               cout << print_SyntaxNodesymb($3) << "\n";
            $$ = new SyntaxNode(LSBRACKET, new IDNode($1), $3);
            //printf("%s\n", print_SyntaxNodesymb($$));
         }
      |  ID LBRACKET INT_VAL SEMICOLON expr_list RBRACKET {
            // This is of the type xh(-1,i) which is xh[i] at a previous stage
            // the ancestor information is conveyed by an ID SyntaxNode with 
            // two arguments, where the second argument is the ancestor
            // $3 is (long int*) => change its sign
            *$3 = -(*$3);
            SyntaxNode *nd = new IDNode($1, *$3);
            $$ = new SyntaxNode(LSBRACKET, nd, $5);
         }      
      |  ANCESTOR LBRACKET INT_VAL RBRACKET DOT iditem {
            // the same as above, just different syntax "ancestor(1).xh[i]"
            // => need to change the ID node in iditem into a binary node
            //    with INT_VAL ($3) as the second argument
   
            // iditem is either an ID or a LSBRACKET node
            SyntaxNode *node = $6;
            IDNode *idnode;
            if (node->opCode==LSBRACKET) {
               idnode = (IDNode*) *(node->begin());
            } else {
               idnode = (IDNode *) node;
            }
            assert(idnode->opCode==ID);
            assert(idnode->stochparent==0);
            idnode->stochparent = *$3;
            $$ = $6;
         }
      ;

/* expr_list: is a comma separated list of expr's */
/* used as argument list to functions 
   RETURNS: 
   *SyntaxNode of type COMMA representing a linked list of items
*/

expr_list:  expr {
               $$ = new SyntaxNode(COMMA, $1);
            }
         |  expr_list COMMA expr {      /* add item to list */
               /* epxr_list could be a simple node or a comma separated
                  list (CSL) already 
                  - if it is a simple node, need to start a comma separated list
                  - if it is a CSL need to add an item to it
               */
               //printf("join nodes >%s< >%s<\n",
               //print_SyntaxNode($1),print_SyntaxNode($3));
               assert($1->opCode==COMMA);
               $$ = $1->push_back($3);
            }
         ;

expr: value
    | LBRACKET expr_list RBRACKET { $$ = new SyntaxNode(LBRACKET, $2); }
    | expr '+' expr { $$ = new OpNode('+', $1, $3); }
    | expr '-' expr { $$ = new OpNode('-', $1, $3); }
    | '-' expr { $$ = new OpNode('-', $2); }
    | expr '*' expr { $$ = new OpNode('*', $1, $3); }
    | expr '/' expr { $$ = new OpNode('/', $1, $3); }
    | expr POWER expr { $$ = new SyntaxNode(POWER, $1, $3); }
    | expr ELLIPSE expr { $$ = new SyntaxNode(ELLIPSE, $1, $3); }
    | expr LOGICAL_OR expr { $$ = new SyntaxNode(LOGICAL_OR, $1, $3); }
    | expr LOGICAL_AND expr { $$ = new SyntaxNode(LOGICAL_AND, $1, $3); }
    | '!' expr { $$ = new SyntaxNode('!', $2); }
    | reduction_op indexing {add_indexing($2);} expr { 
         /* reduction operator: do we need to keep track of the ID of the
            dummy variable(s)? */
         $$ = new SyntaxNode((int)$1, $2, $4);
         rem_indexing($2);
      }
    | IF lexpr THEN expr { $$ = new SyntaxNode(IF, $2, $4); }
    | IF lexpr THEN expr ELSE expr { $$ = new SyntaxNode(IF, $2, $4, $6); }
    | FIRST LBRACKET setexpression RBRACKET { $$ = new SyntaxNode(FIRST, $3); }
    | LAST LBRACKET setexpression RBRACKET { $$ = new SyntaxNode(LAST, $3); }
    | EXPECTATION LBRACKET expr_list RBRACKET { 
         //$$ = new SyntaxNode(EXPECTATION, new SyntaxNode(LBRACKET, $3));}
         $$ = new SyntaxNode(EXPECTATION, $3);
      }
    | func LBRACKET expr_list RBRACKET { /* function definition */
         $$ = new SyntaxNode($1, new SyntaxNode(LBRACKET, $3));
      }
    ;

func :   ORD { $$=ORD; }
     |   CARD { $$=CARD; }
     ;

reduction_op:  SUM { $$=SUM; }
            |  MAX { $$=MAX; }
            |  MIN { $$=MIN; }
            |  PROD { $$=PROD; }
            ;

value:   INT_VAL {
            $$=new ValueNode<long>(*$1);
         }
     |   FLOAT_VAL { 
            $$=new ValueNode<double>(*$1);
         }
     |   identifier { 
            $$=new SyntaxNode(0, $1);
         }
     |   INFINITY { 
            $$ = new SyntaxNode(INFINITY);
         }
     |   STAGE { 
            $$ = new StageNodeNode(STAGE);
         }
     |   NODE { 
            $$ = new StageNodeNode(NODE);
         }
     ;

/* ----------------------------------------------------------------------------
 stuff for the data file reader to follow
---------------------------------------------------------------------------- */
//data_statements: /* empty */
//          | data_statements data_statement 
//          ;
//
//data_statement: data_paramdef SEMICOLON
//              | data_setdef SEMICOLON
//              ;
//
//data_setdef: SET ID ASSIGN setelements
//
//setelements: /* empty */
//           | setelements setelement
//           ;
//
//setelement: ID
//         
//data_paramdef: PARAM ID ASSIGN valuelist
//
//valuelist: value
//         | valuelist value
//         ;
%%

void yyerror(char *s) {
   cerr << "MODEL: " << s << " on line " << yylineno << "\n";
   //fprintf(stderr, "%s\n", s);
}


/* ----------------------------------------------------------------------------
yywrap
---------------------------------------------------------------------------- */
/* not sure if this is correct, found this somewhere on the internet
   should open the data file and somehow tell the parser to carry on 
   reading in "data mode"

 */
int yywrap(void) {
   return 1;
}

/* ----------------------------------------------------------------------------
begin_model
---------------------------------------------------------------------------- */
void
begin_model(char *name, SyntaxNode *indexing) {
  AmplModel *new_mod = new AmplModel;
  ModelComp *newmc;
  
  cout << "Start Model: " << name << "\n";
  new_mod->name = strdup(name);

  /* FIXME: include attrib in definition */
  newmc = new ModelComp(name, TMODEL, indexing, NULL);
  newmc->other = new_mod;

  new_mod->node = newmc;            /* add pointer-to-node to the model */
  current_model->addComp(newmc);
 
  new_mod->setGlobalName();    
  /* and change current model */
  current_model = new_mod;
}

/* ----------------------------------------------------------------------------
begin_smodel
---------------------------------------------------------------------------- */
void
begin_smodel(char *name, SyntaxNode *indexing, SyntaxNode *stochsets) {
   StochModel *new_mod;
   ModelComp *newmc;
  
   if (stochsets->opCode!=COMMA || stochsets->nchild()!=4){
      cerr << "Syntax error in Stochastic Block definition: \n";
      cerr << " 'USING' needs 4 parameters \n";
      exit(1);
   }

   if (GlobalVariables::logParseModel)
      cout << "Start Stochastic Model: " << name << "\n";

   SyntaxNode::iterator i = stochsets->begin();
   SyntaxNode *stages = *i;
   SyntaxNode *nodes = *(++i);
   SyntaxNode *anc = *(++i);
   SyntaxNode *prob = *(++i);
   new_mod = new StochModel(stages, nodes, anc, prob, current_model);
   new_mod->name = strdup(name);
  
   /* Fixme: include attrib in definition */
   newmc = new ModelComp(name, TMODEL, indexing, NULL);
   newmc->other = new_mod;

   new_mod->node = newmc;            /* add pointer-to-node to the model */
   current_model->addComp(newmc);
 
   new_mod->setGlobalName();    
   /* and change current model */
   current_model = new_mod;
   is_stoch_model = true;
}

/* ----------------------------------------------------------------------------
end_model
---------------------------------------------------------------------------- */
void
end_model() {
   current_model = current_model->parent;
}

/* ----------------------------------------------------------------------------
end_smodel
---------------------------------------------------------------------------- */
void
end_smodel(){
  // current_model is a StochModel -> convert this into a tree a FlatModels

  // this is the ModelComp pointing to the StochModel
  ModelComp *mc = current_model->node; 
  
  // point that to the expanded flat model tree
  mc->other = ((StochModel*)current_model)->expandToFlatModel();

  // and change the name of the ModelComp of this model to the name of the 
  // new (AmplModel) model. 
  // (this is a concatenation of the StochModel name and the name of the 
  // first stage)
  mc->id = strdup(((StochModel*)mc->other)->name);

  // and go back to the parent 
  current_model = current_model->parent;
  is_stoch_model = false;
}

/* ----------------------------------------------------------------------------
add_set_to_model
---------------------------------------------------------------------------- */
ModelComp *
add_set_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib){
   ModelComp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TSET, indx, attrib);
   }else{
      newmc = new ModelComp(id, TSET, indx, attrib);
   }
   current_model->addComp(newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

   return newmc;
}

/* ----------------------------------------------------------------------------
add_obj_to_model
---------------------------------------------------------------------------- */
ModelComp *
add_obj_to_model(int token, char *id, SyntaxNode *indx, SyntaxNode *attrib){
   ModelComp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TMIN, indx, attrib);
   }else{
      newmc = new ModelComp(id, TMIN, indx, attrib);
   }
   if (token==MAXIMIZE) newmc->type = TMAX;
   //newmc->ismin = (token==MINIMIZE);

   current_model->addComp(newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

   return newmc;
}

/* ----------------------------------------------------------------------------
add_cons_to_model
---------------------------------------------------------------------------- */
ModelComp *
add_cons_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib){
   ModelComp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TCON, indx, attrib)   ;
   }else{
      newmc = new ModelComp(id, TCON, indx, attrib)   ;
   }
   current_model->addComp(newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

   /*
   if (current_model->cons==NULL){
      current_model->cons = newmc;
   }else{
      ModelComp *last = current_model->cons;
      while(last->next!=NULL) last = last->next;
      last->next = newmc;
   }
   current_model->n_cons++;
   */

   return newmc;
}

/* ----------------------------------------------------------------------------
add_var_to_model
---------------------------------------------------------------------------- */
ModelComp *
add_var_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib){
   ModelComp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TVAR, indx, attrib);
   }else{
      newmc = new ModelComp(id, TVAR, indx, attrib);
   }
   current_model->addComp(newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

   return newmc;
}


/* ----------------------------------------------------------------------------
add_param_to_model
---------------------------------------------------------------------------- */
ModelComp *
add_param_to_model(char *id, SyntaxNode *indx, SyntaxNode *attrib){
   ModelComp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TPARAM, indx, attrib);
   }else{
      newmc = new ModelComp(id, TPARAM, indx, attrib);
   }
   current_model->addComp(newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
    
   /*
   if (current_model->params==NULL){
      current_model->params = newmc;
   }else{
      ModelComp *last = current_model->params;
      while(last->next!=NULL) last = last->next;
      last->next = newmc;
   }
   current_model->n_params++;
   */

   return newmc;
}


/* ------------------------------------------------------------------------
add_indexing/rem_indexing
-------------------------------------------------------------------------- */
void 
add_indexing(SyntaxNodeIx *indexing){
   list_of_indexing[n_indexing] = indexing;
   if (GlobalVariables::logParseModel){
      cout << "add indexing expression to list: " << *indexing << "\n";
      cout << "Symbolic indexing: " << print_SyntaxNodesymb(indexing) << "\n";
      cout << "length of indexing now: " << n_indexing+1 << "\n";
   }
   n_indexing++;
}

void
rem_indexing(SyntaxNodeIx *indexing){
   if (indexing){
      assert(indexing==list_of_indexing[n_indexing-1]);
      if (GlobalVariables::logParseModel) 
         cout << "rem indexing expression to list: " << *indexing << "\n";
   }
   if (GlobalVariables::logParseModel) 
      cout << "length of indexing now: " << n_indexing-1 << "\n";
   n_indexing--;
}

/* ---------------------------------------------------------------------------
Stochastic model helper functions
---------------------------------------------------------------------------- */
void 
addStochInfo(StochModelComp *newmc)
{
   newmc->is_deterministic = is_deterministic_loc | is_deterministic_glo;
   if (stages_loc){
      newmc->stageset = stages_loc;
   }else{
      newmc->stageset = stages_glo;
   }
   newmc->stochmodel = static_cast<StochModel*>(newmc->model);   
   if (newmc->stochmodel==NULL){
      cerr << "addStochInfo: dynamic cast failed!\n";
      exit(1);
   }
   stages_loc = NULL;
   is_deterministic_loc = false;
}

void parse_model(char *filename) {
   if (filename){
      yyin = fopen(filename, "r");
      if (yyin==NULL){
         cerr << "ERROR: file '" << filename << "' not found" << endl;
         exit(1);
      }
   }

   // Change directory to make things work
   int errcode = chdir("tmp");
   if (errcode){
      cerr << "Could not change working directory to 'tmp/'\n";
      cerr << "Cannot continue\n";
      exit(1);
   }


   AmplModel::root = new AmplModel("root");
   current_model = AmplModel::root;
   is_stoch_model = false;
   is_deterministic_loc = false;
   stages_loc = NULL;
   is_deterministic_glo = false;
   stages_glo = NULL;

   errcode = yyparse();
   if (errcode!=0){
      cerr << "yyparse returns " << errcode << endl;
      exit(1);
   } 

   fclose(yyin);

   // Restore original directory
   errcode = chdir("..");
   if (errcode){
      cerr << "Could not change working directory to 'tmp/'\n";
      cerr << "Cannot continue\n";
      exit(1);
   }
}
