%debug

%{
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <assert.h>
   /*#include "parser.h"*/
   #include "nodes.h"
   #include "ampl.h"
   #include "symtab.h"
   #include "backend.h"
   int yylex(void);
   void yyerror(char *s);
   /* global variables */
   static AmplModel *current_model;   /* this is the model currently active */
                                       /* this is the GLOBAL context */
   static AmplModel *local_context;   /* this is theh LOCAL context */
   static int use_local;               /* flag to indicate that local should
					  be used */
   AmplModel *model_tree_root;       /* this is the complete model tree
					 as build at the moment */
   static opNodeIx *list_of_indexing[20];   /* list of currently applicable 
					    indexing expressions */
   static int n_indexing;

   void add_cons_to_model(char *id, opNode *indx, opNode *attrib);
   void add_param_to_model(char *id, opNode *indx, opNode *attrib);
   void add_var_to_model(char *id, opNode *indx, opNode *attrib);
%}

%union
{
  int optype;
  long *ival;
  double *fval;
  char *string;
  opNode *opPtr;
  opNodeIx *opPtrIx;
  //retType *ret;
  //relNode *relPtr;
  //indexNode *indexPtr;
}

%type <string> cnstr
%type <opPtr> expr value  equation expr_list 
%type <opPtr> setattributes setattribute paramattributes paramattribute 
%type <opPtr> varattributes varattribute setexpr_list lexpr 
%type <opPtr> setexpression identifier iditem setexpr_item dummy_member
%type <opPtrIx> indexing indexing_opt
%type <optype> relop reduction_op func

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITY COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE
%token NET_IN NET_OUT DIMEN NODE ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED LOGICAL_OR LOGICAL_AND ELLIPSE
%token PUBLIC CORE DOT BEG TIMESTAGE RANDOM SUFFIX BLOCK IDREF IDREFM

%right ASSIGN
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NE
%left LT LE GT GE
%left '+' '-'
%left '*' '/'
%right POWER
%left '!'
%left ELLIPSE

%%
statements: /* empty */
          | statements statement 
          ;

block: modelblock
     | coreblock
     | blockblock
     ;

modelblock: modelblockbegin statements modelblockend

/* a model command sets up a submodel of the current model */
modelblockbegin: MODEL ID optionlist {begin_model((char *)$2, NULL);}
               | MODEL MODELTYPE ID optionlist {begin_model((char*)$3, NULL);}
               ;

modelblockend: END MODEL {end_model();}

optionlist: /*empty */
          | LBRACKET commasepoptions RBRACKET
          ;

commasepoptions: ID
               | ID COMMA commasepoptions
               ;
/* -------------------------------------------------------------------- 
  blockblock
------------------------------------------------------------------------- */
/* A blockblock is a block definition of the form

     block name{indexing}:
       statements
     end block;

which means that all the statements within the block are repeated over the
indexing expression 
*/

blockblock: blockblockbegin statements blockblockend

blockblockbegin: BLOCK ID indexing_opt COLON {
                    add_indexing($3);
                    begin_model((char*)$2, $3); }

blockblockend: END BLOCK SEMICOLON {end_model();
		 rem_indexing(NULL);
               }

/* -------------------------------------------------------------------- 
  coreblock
------------------------------------------------------------------------- */

coreblock: BEG CORE statements END CORE


statement: setdef SEMICOLON
         | paramdef SEMICOLON
         | vardef SEMICOLON
//         | defn SEMICOLON
//         | assignment SEMICOLON
         | cnstr SEMICOLON
         | command SEMICOLON
         | block
         | INCLUDE ID SEMICOLON
         | set_default COLON
         ;

set_default: TIMESTAGE INT_VAL
           ;

/* FIXME */
command: SOLVE
       | LET indexing identifier DEFINED expr
       ;

/* the first three items define a var/parameter */
//assignment: defn ASSIGN expr
//          | defn EQ expr
//          | defn bd_list
//          | equation
//          ;

/* this looks to be redundant: used from assignment */
//bd_list: bd_list COMMA bound
//       | bound
//       ;

relop: LE {$$=LE;}
     | GE {$$=GE;}
     | LT {$$=LT;}
     | GT {$$=GT;}
     | ASSIGN {$$=ASSIGN;}
     | EQ {$$=EQ;}
     | NE {$$=NE;}
     ;

/* this looks to be redundant: used from bd_list */
//bound: LE expr
//     | LT expr
//     | GE expr
//     | GT expr
//     ;

equation: expr ASSIGN expr { $$ = newBinOp(ASSIGN, $1, $3); }
        | expr LT expr { $$ = newBinOp(LT, $1, $3); }
        | expr LE expr { $$ = newBinOp(LE, $1, $3); }
        | expr GT expr { $$ = newBinOp(GT, $1, $3); }
        | expr GE expr { $$ = newBinOp(GE, $1, $3); }
        | expr EQ expr { $$ = newBinOp(EQ, $1, $3); }
        ;

cnstr: MAXIMIZE ID indexing_opt {if ($3) add_indexing($3);} COLON expr {
          defineSymbol(MAXIMIZE, $2, $3, current_model); 
	  add_obj_to_model(MAXIMIZE, $2, $3, $6);	  
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
| MINIMIZE ID indexing_opt {if ($3) add_indexing($3);} COLON expr {
          defineSymbol(MINIMIZE, $2, $3, current_model); 
	  add_obj_to_model(MINIMIZE, $2, $3, $6);	  
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
| SUBJECTTO ID indexing_opt {if ($3) add_indexing($3);} COLON equation { 
          defineSymbol(SUBJECTTO, $2, $3, current_model); 
	  add_cons_to_model($2, $3, $6);
	  if ($3) rem_indexing($3);
	  $$=$2;
         }
     ;

indexing_opt: /* empty */ {$$=NULL;}
            | indexing {$$=$1;}
            ;

indexing: LBRACE setexpr_list COLON lexpr RBRACE {
	   opNode *tmp = newUnaryOp(LBRACE, newBinOp(COLON, $2, $4));
           $$ = new opNodeIx(tmp);
          }
        | LBRACE setexpr_list RBRACE {
	    opNodeIx *tmp = new opNodeIx(newUnaryOp(LBRACE, $2));
	    $$=tmp;
          }
        ;

//domain: /* empty */ { $$=NULL }
//      | LBRACE setexpr_list RBRACE {/* $$ = $2*/ }
         ;

/* FIXME: ID IN setexpression defines a dummy variable (?)
   -> have this as a separate construct
   -> how to deal with dummy variables? */
setexpr_list: setexpr_item
            | setexpr_list COMMA setexpr_item{
                if ($1->opCode==COMMA){
		  $$ = addItemToListNew($1, $3);
		}else{
		  $$ = newBinOp(COMMA, $1, $3);
		}
              }
            ;

setexpr_item : setexpression
             | dummy_member IN setexpression{
               $$ = newBinOp(IN, $1,$3);}
             ;

dummy_member : ID {$$=newUnaryOp(ID, $1);}
             | LBRACKET ID COMMA ID RBRACKET {
	        opNode *tmp = newUnaryOp(LBRACKET, 
   	          newBinOp(COMMA, newUnaryOp(ID,$2), newUnaryOp(ID,$4)));
	       $$ = tmp;}
             ;

lexpr: expr
     | LBRACKET lexpr RBRACKET {
	$$ = newUnaryOp(LBRACKET, $2); }
     | equation
     ;

setdef: SET ID indexing_opt {if ($3) add_indexing($3);} setattributes{ 
          defineSymbol(SET, $2, $3, current_model); 
	  add_set_to_model($2, $3, $5);
	  if ($3) rem_indexing($3);
	  //$$=$2; 
        };

paramdef: qualifier PARAM ID indexing_opt {if ($4) add_indexing($4);} paramattributes{
            defineSymbol(PARAM, $3, $4, current_model); 
	    add_param_to_model($3, $4, $6);
	    if ($4) rem_indexing($4);
	    //$$=$2; 
          };

vardef: VAR ID indexing_opt {if ($3) add_indexing($3);} varattributes{
            defineSymbol(VAR, $2, $3, current_model); 
	    add_var_to_model($2, $3, $5);
   	    if ($3) rem_indexing($3);
	    //$$=$2; 
          };



qualifier: /* empty */
         | PUBLIC
         | RANDOM
         ;

/* these are SET definitions */

setattributes: /* empty */ {$$=NULL;}
             | setattributes setattribute {
  	         $$ = newBinOp(' ', $1, $2); }
             ;

setattribute: DIMEN INT_VAL {
                 $$ = newUnaryOp(DIMEN, newUnaryOp(INT_VAL, $2));}
            | WITHIN setexpression {
                 $$ = newUnaryOp(WITHIN, $2);}
            | ASSIGN setexpression {
                 $$ = newUnaryOp(ASSIGN, $2);}
            | DEFAULT setexpression {
                 $$ = newUnaryOp(DEFAULT, $2);}
            | ORDERED { $$ = newUnaryOp(ORDERED, NULL);}
            ;
paramattributes: /* empty */ {$$ = NULL;}
               | paramattributes paramattribute {
		   $$ = newBinOp(' ', $1, $2);}
             ;

paramattribute: BINARY {$$ = newUnaryOp(BINARY, NULL);}
              | INTEGER {$$ = newUnaryOp(INTEGER, NULL);}
              | SYMBOLIC {$$ = newUnaryOp(SYMBOLIC, NULL);}
              | relop expr  {$$ = newUnaryOp($1, $2);}
              | IN setexpression {$$ = newUnaryOp(IN, $2);}
              | ASSIGN expr {$$ = newUnaryOp(ASSIGN, $2);}
              | DEFAULT expr {$$ = newUnaryOp(DEFAULT, $2);}
              ;
varattributes: /* empty */ {$$=NULL;}
             | varattributes varattribute{
                $$ = newBinOp(' ', $1, $2);}
             ;

/* FIXME: what to do about the ID in the last rule ? */
varattribute: BINARY {$$ = newUnaryOp(BINARY, NULL);}
            | INTEGER {$$ = newUnaryOp(INTEGER, NULL);}
            | SYMBOLIC {$$ = newUnaryOp(SYMBOLIC, NULL);}
            | LE expr {$$ = newUnaryOp(LE, $2);}
            | GE expr {$$ = newUnaryOp(GE, $2);}
            | DEFINED expr {$$ = newUnaryOp(DEFINED, $2);}
            | ASSIGN expr {$$ = newUnaryOp(ASSIGN, $2);}
            | DEFAULT expr {$$ = newUnaryOp(DEFAULT, $2);}
	      //| COEFF indexing_opt constraint expr
	      //| COVER indexing_opt constraint expr
	      //| OBJ indexing_opt objective expr
            | IN setexpression {$$ = newUnaryOp(IN, $2);}
            | SUFFIX ID expr {$$ = newUnaryOp(SUFFIX, $3);}
            ;

/* this is anything that evaluates to a set */
setexpression: LBRACE expr_list RBRACE  {$$ = newUnaryOp(LBRACE, $2);}
             | identifier    /* already defined identifier */ 
//             | indexing
             | setexpression CROSS setexpression {
	       $$ = newBinOp(CROSS, $1, $3);}
             | setexpression DIFF setexpression {
	       $$ = newBinOp(DIFF, $1, $3);}
             ;

/* Identifier is any quotation of a predefined object:
    RoutComm[j].Flow[k-3*j, k]#
*/
identifier: iditem {
             /* this is a simple identifier in global context */
             $$ = find_var_ref_in_context(current_model, $1);
            }
          | identifier DOT iditem{
	    /* identifier sets the context for the iditem:
	       The result of this is either a context setting or a
	       complete description of a variable.

	       Can implement this by simply adding context and argument lists
	    
	       A variable reference should be represented internally as a
	       pointer to the referenced object in the model list
	       and a pointer to the list of arguments

	       This can be represented as a opNode with
	       ->opCode = ID;
	       ->nval = # of arguments
	       ->values[0] = pointer to entity in model list
	       ->values[1 - n] = arguments 

	       CONTEXT: iditems can be interpreted in two different contexts
	        1) is the global context (i.e. referring from the model
		   part that is currently defined)
                2) is a local context that can be set by preceeding bits
		   of a dot'd expression. If a dot'd expression is 
		   parsed the flag 'local_context' should be set and 
		   'local_context' should be set to the current local
		   context. 
                a context is epressed as a pointer to a model entity

	    */
	    
	    /* identifier sets the context for the idem */
	    /* this only works if the identifier is actually a reference 
	       to a submodel */
 	      void **newvalues;
	      int i;

	      if ($1->opCode!=IDREFM){
		printf("Attempting to use dot specifier for something not an");
		char *tmp1 = print_opNode($1);
		printf(" object:\n %s\n", tmp1);
		free(tmp1);
		exit(1);
	      }
	      local_context = (AmplModel*)((model_comp*)($1->values[0]))->other;

	      char *tmp1 = print_opNode($1);
	      char *tmp2 = print_opNode($3);
	      printf("Trying to merge \n identifier %s", tmp1);
	      printf(" and iditem %s\n", tmp2);
	      free(tmp1);
	      free(tmp2);
	      $$ = find_var_ref_in_context(local_context, $3);

	      /* merge argument lists */
	      newvalues = (void **)calloc($1->nval+$$->nval+1,sizeof(void *));
	      for(i=0;i<$1->nval;i++)
		newvalues[i+1] = $1->values[i+1];
	      for(i=0;i<$$->nval;i++)
		newvalues[$1->nval+i+1] = $$->values[i+1];
	      newvalues[0] = $$->values[0];
	      $$->nval += $1->nval;
	      free($$->values);
	      $$->values = newvalues;

	    }
          ;




iditem: ID {                               /* simple identifier */
          $$=newUnaryOp(ID, $1);}
      | ID LSBRACKET expr_list RSBRACKET { /* subscripted id'fier */
        char *tmp = print_opNodesymb($3);
        printf("%s\n", tmp);
        free(tmp);
	$$ = newBinOp(LSBRACKET, newUnaryOp(ID,$1), $3);
        //printf("%s\n", print_opNodesymb($$));
      }
/* FIXME: this is the problem, ID is not of type */
      ;

/* expr_list: is a comma separated list of expr's */
/* used as argument list to functions 
   RETURNS: 
   *opNode of type COMMA representing a linked list of items
*/

expr_list: expr {
  //              indexNode *ixn = newIndexNode($1); 
  //             $$ = newBinOp(COMMA, ixn, ixn); /* set up a list */
               $$ = newUnaryOp(COMMA, $1);
           }
         | expr_list COMMA expr {      /* add item to list */
	   /* epxr_list could be a simple node or a comma separated list (CSL)
	      already 
	      - if it is a simple node, need to start a comma separated list
	      - if it is a CSL need to add an item to it
	   */
	   //printf("join nodes >%s< >%s<\n",
	   //	  print_opNode($1),print_opNode($3));
	   assert($1->opCode==COMMA);
 	   //if ($1->opCode==COMMA){
	     /* is CSL already => add item to it */
	     $$ = addItemToListNew($1, $3);
	     //}else{
	     /* start new CSL */
	     //printf("Start new CSL\n");
	     ////indexNode *ixn = newIndexNode($1); 
	     ////opNode *tmp = newBinOp(COMMA, ixn, ixn); /* set up a list */
	     ////tmp->nval = 1;
	     ////$$ = addItemToList(tmp, $3);
	     //$$ = newBinOp(COMMA, $1, $3);
	     //}
	 }
         ;

expr: value
    | LBRACKET expr_list RBRACKET {$$ = newUnaryOp(LBRACKET, $2);}
    | expr '+' expr { $$ = newBinOp('+', $1, $3); }
    | expr '-' expr { $$ = newBinOp('-', $1, $3); }
    | expr '*' expr { $$ = newBinOp('*', $1, $3); }
    | expr '/' expr { $$ = newBinOp('/', $1, $3); }
    | expr POWER expr { $$ = newBinOp(POWER, $1, $3); }
    | expr ELLIPSE expr { $$ = newBinOp(ELLIPSE, $1, $3); }
    | expr LOGICAL_OR expr { $$ = newBinOp(LOGICAL_OR, $1, $3); }
    | expr LOGICAL_AND expr { $$ = newBinOp(LOGICAL_AND, $1, $3); }
    | '!' expr { $$ = newUnaryOp('!', $2) };
    | reduction_op indexing {add_indexing($2);} expr { 
      /* reduction operator: do we need to keep track of the ID of the
	 dummy variable(s)? */
      $$ = newBinOp((int)$1, $2, $4);
      rem_indexing($2);}
    | IF lexpr THEN expr {
	$$ = newBinOp(IF, $2, $4);}
    | IF lexpr THEN expr ELSE expr {
	$$ = newTertOp(IF, $2, $4, $6);}
    | func LBRACKET expr_list RBRACKET { /* function definition */
         $$ = newUnaryOp($1, newUnaryOp(LBRACKET, $3));}
    ;

func : ORD {$$=ORD;}
     | CARD {$$=CARD;}
     ;

reduction_op: SUM {$$=SUM;}
            | MAX {$$=MAX;}
            | MIN {$$=MIN;}
            | PROD {$$=PROD;}
            ;

value: INT_VAL {
  /* not entirly sure what is returned here as $1 */
          $$=newUnaryOp(INT_VAL, $1);
	  //$$ = (opNode *) malloc(sizeof(opNode));
	  //$$->opCode = INT_VAL;
	  //$$->values = (void **) malloc(1*sizeof(void *));
	  //$$->values[0] = (int *) malloc(sizeof(int));
	  //*((int *) $$->values[0]) = $1;
       }
     | FLOAT_VAL { 
         $$=newUnaryOp(FLOAT_VAL, $1);
       //$$ = (opNode *) malloc(sizeof(opNode));
       //$$->opCode = FLOAT_VAL;
       //$$->values = (void **) malloc(1*sizeof(void *));
       //$$->values[0] = (double *) malloc(sizeof(double));
       //*((double *) $$->values[0]) = $1;
       }
     | identifier { 
          $$=newUnaryOp(0, $1);
       //$$ = (opNode *) malloc(sizeof(opNode));
       //  $$->opCode = ID;
       //  $$->values = (void **) malloc(1*sizeof(void *));
       //  $$->values[0] = (void *) $1;
       }
     | INFINITY { 
          $$ = (opNode *) malloc(sizeof(opNode));
          $$->opCode = INFINITY;
          $$->values = NULL;
       }
     ;

%%

void yyerror(char *s) {
  //fprintf(stderr, "%s on line %i\n", s, yylineno);
  fprintf(stderr, "%s\n", s);
}

int yywrap(void) {
   return 1;
}

int main(int argc, char **argv) {
   if(argc > 1 && strcmp(argv[1], "-d") == 0)
      yydebug = 1;

   /* set up global symbol list here */
   symb_entry **sht = (symb_entry**)calloc(N_HASH, sizeof(symb_entry*));

   /* setup the root of the model tree */
   //model_tree_root = (AmplModel*)calloc(1, sizeof(AmplModel));
   model_tree_root = new AmplModel;
   current_model = model_tree_root;
   current_model->symb_hash_table = sht;
   current_model->name = (char *)&("root");
   current_model->parent = NULL;
   current_model->setGlobalName();

   yyparse();
   
   do_stuff(current_model);

   return 0;
}

/* ----------------------------------------------------------------------------
begin_model
---------------------------------------------------------------------------- */
void
begin_model(char *name, opNode *indexing) {
  AmplModel *new_mod = new AmplModel;
  symb_entry **sht = (symb_entry**)calloc(N_HASH, sizeof(symb_entry*));
  model_comp *newmc;
  
  printf("Start Model: %s\n",name);
  new_mod->symb_hash_table = sht;
  new_mod->name = strdup(name);

  /* FIXME: include attrib in definition */
  newmc = new model_comp(name, TMODEL, indexing, NULL);
  newmc->other = new_mod;

  new_mod->node = newmc;            /* add pointer-to-node to the model */
  current_model->addComponent(newmc);
 
  new_mod->setGlobalName();	 
  /* and change current model */
  current_model = new_mod;
}

/* ----------------------------------------------------------------------------
end_model
---------------------------------------------------------------------------- */
void
end_model(){
  current_model = current_model->parent;
}

/* ----------------------------------------------------------------------------
add_set_to_model
---------------------------------------------------------------------------- */
void
add_set_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc = new model_comp(id, TSET, indx, attrib);

  current_model->addComponent(newmc);
  /*
  if (current_model->sets==NULL){
    current_model->sets = newmc;
  }else{
    model_comp *last = current_model->sets;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_sets++;
  */
}

/* ----------------------------------------------------------------------------
add_obj_to_model
---------------------------------------------------------------------------- */
void
add_obj_to_model(int token, char *id, opNode *indx, opNode *attrib){
  model_comp *newmc = new model_comp(id, TOBJ, indx, attrib);
  newmc->ismin = (token==MINIMIZE);

  current_model->addComponent(newmc);
  /*
  if (current_model->objs==NULL){
    current_model->objs = newmc;
  }else{
    model_comp *last = current_model->objs;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_objs++;
  */
}

/* ----------------------------------------------------------------------------
add_cons_to_model
---------------------------------------------------------------------------- */
void
add_cons_to_model(char *id, opNode *indx, opNode *attrib){
  //model_comp *newmc = newModelComp(id, TCON, indx, attrib);
  model_comp *newmc = new model_comp(id, TCON, indx, attrib)	;
  current_model->addComponent(newmc);

  /*
  if (current_model->cons==NULL){
    current_model->cons = newmc;
  }else{
    model_comp *last = current_model->cons;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_cons++;
  */
}
/* ----------------------------------------------------------------------------
add_var_to_model
---------------------------------------------------------------------------- */
void
add_var_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc = new model_comp(id, TVAR, indx, attrib);
  current_model->addComponent(newmc);

  /*
  if (current_model->vars==NULL){
    current_model->vars = newmc;
  }else{
    model_comp *last = current_model->vars;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_vars++;
  */
}


/* ----------------------------------------------------------------------------
add_param_to_model
---------------------------------------------------------------------------- */
void
add_param_to_model(char *id, opNode *indx, opNode *attrib){
  model_comp *newmc = new model_comp(id, TPARAM, indx, attrib);
  current_model->addComponent(newmc);

  /*
  if (current_model->params==NULL){
    current_model->params = newmc;
  }else{
    model_comp *last = current_model->params;
    while(last->next!=NULL) last = last->next;
    last->next = newmc;
  }
  current_model->n_params++;
  */
}

/* ----------------------------------------------------------------------------
 makeListOfDependencies
---------------------------------------------------------------------------- */
/* this routine makes a list of dependencies of one object on other 
   objects:

   it first scans through the indexing part identifying all dummy
   variables.

   all entities referenced in either the indexing part or attribute part are
   identified (i.e. their entry_atom is found) and a list of them is generated


*/

void
makeListOfDependencies(opNode *indx, opNode *attrib)
{
  /* identify all dummy variables from the indexing part */
  /* => is it correct to assume that anything to the left of keyword 'IN'
        is a dummy variable ? */

  opNode *tmpnode;
  int ndummy;
  char **ldummy;
  int nlist;     /* length of list */


  tmpnode = findKeywordinTree(indx, IN);
  
  /* okay: count number of dummy variables */
  ndummy = countKeywordinTree((opNode*)tmpnode->values[0], ID);
  ldummy = (char **)calloc(ndummy, sizeof(char*));
  /* and make a list of dummy variables */
  findIDinTreeAndAddToList((opNode*)tmpnode->values[0], ldummy, &nlist);

  /* and make a list of all variables */
  findIDinTreeAndAddToList(indx, ldummy, &nlist);
  findIDinTreeAndAddToList(attrib, ldummy, &nlist);
  
  /* FIXME: 
    - add pointer to counter to argument list above 
    - ldummy array needs to be allocated with enough space 
    - the last two adding ID calls need to try to find the
       added entity in the current hash table and add the atom_entry to the
       list (rather than just the name as is at the moment)
       => ldummy should be a var_entry *list
    - the whole thing needs to be called from outside
      with every c/s, var, etc definition statement
  */
}

/* ----------------------------------------------------------------------------
findKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

opNode *
findKeywordinTree(opNode *root, int oc)
{
  opNode *res1, *res2;;
  if (root->opCode==oc) return root;
  
  if (root->nval==0) return NULL;
  res1 = findKeywordinTree((opNode*)root->values[0], oc);
  if (root->nval==1) return res1;
  res2 = findKeywordinTree((opNode*)root->values[1], oc);
  if (res1 && res2) {
    printf("Found keyword %d at least twice in %s\n",oc, print_opNode(root));
    exit(1);
  }
  if (res1) {
    return res1;
  }else{
    return res2;
  }
}

/* ----------------------------------------------------------------------------
countKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and counts the number of keyword 'oc'
   nodes in the tree */


int
countKeywordinTree(opNode *root, int oc)
{
  int i, ret = 0;
  if (root->opCode==oc) return 1;
  
  for(i=0;i<root->nval;i++){
    ret += countKeywordinTree((opNode*)root->values[i], oc);
  }
  return ret;
}

/* ----------------------------------------------------------------------------
findIDinTreeAndAddToList(tmpnode->values[0], ldummy);
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

void
findIDinTreeAndAddToList(opNode *node, char  **list, int *nlist)
{
  int i;

  if (node->opCode==ID){
    int found = 0;
    /* add the variable name to the list */
    /* should check that the name is not on the list already */
    printf("Consider to add name %s to list\n",node->values[0]);
    for(i=0;i<(*nlist);i++){
      if (strcmp((const char*)node->values[0], list[i])==0)
	found = 1;
    }

    if (found==0){
      list[*nlist] = (char*)node->values[0];
      (*nlist)++;
    }
    return;
  }
  for (i=0;i<node->nval;i++){
    findIDinTreeAndAddToList((opNode*)node->values[i], list, nlist);
  }
  
}

/* ---------------------------------------------------------------------------
find_var_ref_in_context
---------------------------------------------------------------------------- */
/* This routine does the work of putting together dot'd variable names
   'root' is a opNode of type ID that points to the left hand part
   of the dot'd expression parsed so far. 'ref' is the new part that
   should be added.

   An opNode of type IDREF looks like this
	       ->opCode = IDREF;
	       ->nval = # of arguments
	       ->values[0] = pointer to entity in model list
	       ->values[1 - n] = arguments 

*/
opNode*
find_var_ref_in_context(AmplModel *context, opNode *ref)
{
  /* 'ref' is an opNode representing an iditem. 
     This can be either
     - a ID node where values[0] simply points to a name
     - a LSBRACKET node, where values[0] is ID and values[1] is CSL
     in the second case the CSL should be added as further arguments
     to the resulting IDREF node

  */
  
  /* returns: pointer 
   */
  int i;
  model_comp *thismc;
  opNode *tmp, *idNode, *argNode;
  AmplModel *thism;
  char *name;
  /* and now scan through the whole of the local context to see if we 
     find any matches */
  /* the local context is 
      - all vars
      - all constraints
      - all objectives
      - all sets
      - all parameters
      - all submodels
      - all temporary variables (this list needs to be set up somewhere)
  */
  
  if (ref->opCode==ID){
    idNode = ref;
    argNode = NULL;
  }else{
    assert(ref->opCode==LSBRACKET);
    idNode = (opNode*)ref->values[0];
    argNode = (opNode*)ref->values[1];
    assert(idNode->opCode==ID);
    assert(argNode->opCode==COMMA);
  }
  name = (char*)idNode->values[0];

  printf("--> search for matches of %s\n",name);
 
  tmp = find_var_ref_in_indexing(name);
  if (tmp) {
    char *tmp1 = print_opNode(tmp);
    printf("%s is matched by dummy var in %s\n",name, tmp1);
    free(tmp1);
    return ref;
  }

  idNode = find_var_ref_in_context_(context, idNode);

  if (argNode){
    void *tmp2 = idNode->values[0];
    char *tmp1 = print_opNode(argNode);
    printf("Adding argument list to node: %s\n", tmp1);
    free(tmp1);
    free(idNode->values);
    idNode->values = (void **)calloc(argNode->nval+1, sizeof(void *));
    for (i=0;i<argNode->nval;i++){
      idNode->values[i+1] = argNode->values[i];
    }
    idNode->nval = argNode->nval;
    free(argNode->values);
    free(argNode);
    idNode->values[0] = tmp2;
  } else {
    idNode->nval = 0;
  }

  return idNode;

}

opNode*
find_var_ref_in_context_(AmplModel *context, opNode *ref)
{
  int i;
  model_comp *thismc;
  opNode *tmp;
  AmplModel *thism;
  char *name = (char*)ref->values[0];
  
  thismc = context->first;
  for(i=0;i<context->n_total;i++){
    if (strcmp(name, thismc->id)==0){
      /* this is a match */
      char *tmp1 = print_opNode(thismc->indexing);
      char *tmp2 = print_opNode(thismc->attributes);
      printf("Found Match: %s refers to %s\n",name, nameTypes[thismc->type]);
      printf("    %s\n",thismc->id);
      printf("       %s\n", tmp1);
      printf("       %s\n", tmp2);
      free(tmp1);
      free(tmp2);
      ref->values[0] = (void*)thismc;
      ref->opCode = IDREF;
      if (thismc->type==TMODEL){
	ref->opCode = IDREFM;
      }
      return ref;
    }
    thismc = thismc->next;
  }
  assert(thismc==NULL);

  
  //thismc = context->vars;
  //for(i=0;i<context->n_vars;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to variable\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->cons;
  //for(i=0;i<context->n_cons;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* thismc is a match */
  //    printf("Found Match: %s refers to constraint\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->sets;
  //for(i=0;i<context->n_sets;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to set\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thismc = context->params;
  //for(i=0;i<context->n_params;i++){
  //  if (strcmp(name, thismc->id)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to parameter\n",name);
  //    printf("    %s\n",thismc->id);
  //    printf("       %s\n",print_opNode(thismc->indexing));
  //    printf("       %s\n",print_opNode(thismc->attributes));
  //    ref->values[0] = (void*)thismc;
  //    ref->opCode = IDREF;
  //    return ref;
  //  }
  //  thismc = thismc->next;
  //}
  //thism = context->submodels;
  //for(i=0;i<context->n_submodels;i++){
  //  if (strcmp(name, thism->name)==0){
  //    /* this is a match */
  //    printf("Found Match: %s refers to submodel\n",name);
  //    printf("    %s\n",thism->name);
  //    //printf("       %s\n",print_opNode(thism->indexing));
  //    //printf("       %s\n",print_opNode(this->attributes));
  //    ref->values[0] = (void*)thism;
  //    ref->opCode = IDREFM;
  //    return ref;
  //  }
  //  thism = thism->next;
  //}

  /* need also to look through parent model */
  if (context->parent){
    opNode *match = find_var_ref_in_context(context->parent, ref);
    return match;
  }

  /* need also to look through list of local variables */

  printf("Could not find ref %s in context\n",name);
  exit(1);

}


/* ---------------------------------------------------------------------------
find_var_ref_in_indexing
---------------------------------------------------------------------------- */
/* scan through the current set of active indexing expressions and see if
   any of them define the dummy variable  given by 'name' 

   IN: 
    char *name                 the name of identifier to look for
    
    int n_indexing             the currently active indexing expressions
    opNode *list_of_indexing
   RETURN:
    The Indexing expression in which the name occurs 
    (or NULL if there is no match)
                                                                      */

opNode *
find_var_ref_in_indexing(char *name)
{
  int i;
  opNodeIx *tmp;
  opNode *ret = NULL;

  for(i=0;i<n_indexing;i++){
    /* have a look at all the indexing expressions */
    /* an indexing expression is a '{' node followed by a 'Comma' node */
    tmp = list_of_indexing[i];
    tmp->splitExpression();
    ret = tmp->hasDummyVar(name);
    if (ret) return ret;
 		
#if 0
    assert(tmp->opCode==LBRACE);
    tmp = (opNode*)tmp->values[0];
    if (tmp->opCode==COLON) tmp = (opNode*)tmp->values[0];
    /* this should now be a comma separated list */
    if (tmp->opCode==COMMA){
      for(j=0;j<tmp->nval;j++){
	tmp2 = findKeywordinTree((opNode*)tmp->values[j], IN);
	/* everything to the left of IN is a dummy variables */
	if (tmp2){
	  tmp2 = (opNode*)tmp2->values[0];
	  assert(tmp2->opCode==ID);
	  printf("Found dummy variable: %s\n",tmp2->values[0]);
	  if (strcmp(name, (const char*)tmp2->values[0])==0)
	    ret = (opNode*)tmp->values[j];
	  
	}
      }
    }else{
      /* if this is not a comma separated list, then look directly */
      char *tmpbuf1 = print_opNode(tmp);
      char *tmpbuf2 = print_opNodesymb(tmp);
      printf(">%s\n", tmpbuf1);
      printf(">%s\n", tmpbuf2);
      free(tmpbuf1);
      free(tmpbuf2);
      tmp2 = findKeywordinTree(tmp, IN);
      /* everything to the left of IN is a dummy variables */
      if (tmp2){
	tmp2 = (opNode*)tmp2->values[0];
	assert(tmp2->opCode==ID||tmp2->opCode==COMMA);
	printf("Found dummy variable: %s\n",tmp2->values[0]);
	if (strcmp(name, (const char*)tmp2->values[0])==0)
	  ret = tmp;
      }
    }
#endif
  }
  return ret;
}

/* ------------------------------------------------------------------------

-------------------------------------------------------------------------- */
void 
add_indexing(opNodeIx *indexing){
  char *tmp1 = print_opNode(indexing);
  char *tmp2 = print_opNodesymb(indexing);
  list_of_indexing[n_indexing] = indexing;
  printf("add indexing expression to list: %s\n", tmp1);
  printf("Symbolic indexing: %s\n", tmp2);
  printf("length of indexing now: %d\n",n_indexing+1);
  free(tmp1);
  free(tmp2);
  n_indexing++;
}

void
rem_indexing(opNodeIx *indexing){
  if (indexing){
    assert(indexing==list_of_indexing[n_indexing-1]);
    char *tmp = print_opNode(indexing);
    printf("rem indexing expression to list: %s\n", tmp);
    free(tmp);
  }
  printf("length of indexing now: %d\n",n_indexing-1);
  n_indexing--;
}
