%debug

%{
   #define YYERROR_VERBOSE
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <assert.h>
   #include <sys/stat.h>
   #include <iostream>
   #include "nodes.h"
   #include "ampl.h"
   #include "GlobalVariables.h"
   #include "StochModel.h"
   #include "StochModelComp.h"
   #include "symtab.h"
   #include "backend.h"
   #include "SetNode.h"
   extern int yylineno;
   int yylex(void);
   void yyerror(char *s);
   /* global variables */
   char *GlobalVariables::modelfilename = NULL;
   char *GlobalVariables::datafilename = NULL;
   char *GlobalVariables::amplcommand = "ampl";

   bool GlobalVariables::logParseModel = false;
   int GlobalVariables::prtLvl = 1;

   static AmplModel *current_model;    /* this is the model currently active */
                                       /* this is the GLOBAL context */
   static AmplModel *local_context;    /* this is the LOCAL context */
   static opNodeIx *list_of_indexing[20];    /* list of currently applicable 
                                                indexing expressions */
   static int n_indexing;
   /* ---------------- stochastic global variables:------------------------ */
   static bool is_stoch_model;      /* true if inside stochastic model def */
   /* these are set within entity definitions and reset at the end of them */
   static bool is_deterministic_loc;
   static opNode *stages_loc;
   /* these are set by global stocastic modifier commands */
   static bool is_deterministic_glo;
   static opNode *stages_glo;
   extern FILE *yyin;
   extern void parse_data(AmplModel *current_model, char *datafilename);

   void add_cons_to_model(char *id, opNode *indx, opNode *attrib);
   void add_param_to_model(char *id, opNode *indx, opNode *attrib);
   void add_var_to_model(char *id, opNode *indx, opNode *attrib);
   void addStochInfo(StochModelComp *newmc);
   void createSubdirTmpIfNotExist(void);
%}

%union
{
  int optype;
  long *ival;
  double *fval;
  char *string;
  opNode *opPtr;
  opNodeIx *opPtrIx;
}

%type <string> cnstr
%type <opPtr> expr value  equation expr_list 
%type <opPtr> setattributes setattribute setattributes_opt
%type <opPtr> stochattr_opt
%type <opPtr> paramattributes_opt paramattributes paramattribute 
%type <opPtr> varattributes_opt varattributes varattribute 
//%type <opPtr> csattributes_opt csattributes csattribute 
%type <opPtr> setexpr_list lexpr 
%type <opPtr> setexpression identifier iditem setexpr_item dummy_member
%type <opPtr> commasepoptions optionlist
%type <opPtrIx> indexing indexing_opt
%type <optype> relop reduction_op func ubsetop bsetop

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITY COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE DOTDOT
%token NET_IN NET_OUT DIMEN ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED LOGICAL_OR LOGICAL_AND ELLIPSE
%token PUBLIC CORE DOT BEG TIMESTAGE RANDOM SUFFIX BLOCK IDREF IDREFM
%token SBLOCK USING DETERMINISTIC EXPECTATION STOCHASTIC STAGES
%token STAGE NODE ANCESTOR

%right ASSIGN
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NE
%left LT LE GT GE
%left '+' '-'
%left '*' '/'
%right POWER
%left '!'
%left ELLIPSE

%%
statements: /* empty */
          | statements statement 
          ;

block:   modelblock
     //| coreblock
     |   stochblock
     |   blockblock
     |   stageblock
     ;

modelblock: modelblockbegin statements modelblockend

/* a model command sets up a submodel of the current model */
modelblockbegin:  MODEL ID optionlist {begin_model((char *)$2, NULL);}
               |  MODEL MODELTYPE ID optionlist {begin_model((char*)$3, NULL);}
               ;

modelblockend: END MODEL {end_model();}

optionlist: /*empty */ {$$=NULL;}
          | LBRACKET commasepoptions RBRACKET {$$=$2;}
          ;

commasepoptions:  identifier {
                     $$ = new opNode(COMMA, $1);}
               |  commasepoptions COMMA identifier{
                     $$ = $1->push_back($3);
                  }
               ;
/* -------------------------------------------------------------------- 
  blockblock
------------------------------------------------------------------------- */
/* A blockblock is a block definition of the form

     block name{indexing}:
       statements
     end block;

which means that all the statements within the block are repeated over the
indexing expression 
*/

blockblock: blockblockbegin statements blockblockend

blockblockbegin:  BLOCK ID indexing_opt COLON {
                     add_indexing($3);
                     begin_model((char*)$2, $3);
                  }

blockblockend: END BLOCK SEMICOLON {
                  end_model();
                  rem_indexing(NULL);
               }
/* -------------------------------------------------------------------- 
  stochblock
------------------------------------------------------------------------- */
/* A stochblock is a block definition of the form

     [sblock/stochastic block] name{indexing} using (STAGES,NODES,ANC,PROB):
       statements
     end sblock;

where 
  STAGES: set of time stages 
  NODES: set of nodes in the tree
  ANC{NODES}: ancestor for every node
  PROB{NODES}: conditional probability of reaching this node from parent

  The whole block is repeated over all STAGES (actually over all NODES). 
  Entities marked 'deterministic' are only repeated over STAGES

--------------------------------------------------------------------
Logic of stochastic qualifiers: deterministic/stages:
 - if an sblock is started, then is_stoch_model is set to true
 - if an sblock is closed, then is_stoch_model is set to false
 - deterministc/stages are read in as attributes to param/set/var/etc defs
 - their value is stored in global variables stages/is_deterministic




*/

stochblock: sblockbegin statements sblockend
          | stochblockbegin statements stochblockend
          | sblockbeginbrace statements RBRACE {
               end_smodel();
               rem_indexing(NULL);
            }
          ;
    
/* FIXME: optionlist is of form '(ID COMMA ID ...)'
     need to call new opNode and addToListItem functions in the 
     processing of optionlist and its children */
stochblockbegin:  STOCHASTIC BLOCK ID indexing_opt USING optionlist COLON {
                     add_indexing($4);
                     begin_smodel((char*)$3, $4, $6);
                  }

sblockbegin:   SBLOCK ID indexing_opt USING optionlist COLON {
                  add_indexing($3);
                  begin_smodel((char*)$2, $3, $5);
               }
           |   BLOCK ID indexing_opt STOCHASTIC USING optionlist COLON {
                  add_indexing($3);
                  begin_smodel((char*)$2, $3, $6);
               }
           ;             

sblockbeginbrace: BLOCK ID indexing_opt STOCHASTIC USING optionlist COLON
                  LBRACE {
                     add_indexing($3);
                     begin_smodel((char*)$2, $3, $6);
                  }
           ;             

stochblockend: END STOCHASTIC BLOCK SEMICOLON {
                  end_model();
                  rem_indexing(NULL);
               }

sblockend:  END SBLOCK SEMICOLON {
               end_smodel();
               rem_indexing(NULL);
            }

/* -------------------------------------------------------------------- 
  stageblock
------------------------------------------------------------------------- */

stageblock: STAGE setexpression COLON {              
               if (!is_stoch_model) { 
                  cerr << "Syntax Error: keyword 'STAGES' can only be used in"
                     "stochastic blocks\n";
                  exit(1);
               }
               stages_glo = $2;
            } LBRACE statements RBRACE {
               stages_glo = NULL;
            }

//coreblock: BEG CORE statements END CORE

statement:  setdef SEMICOLON
         |  paramdef SEMICOLON
         |  vardef SEMICOLON
         |  cnstr SEMICOLON
         |  command SEMICOLON
         |  block
         |  INCLUDE ID SEMICOLON
         |  set_default COLON
         ;

set_default: TIMESTAGE INT_VAL
           ;

/* FIXME */
command: SOLVE
       | LET indexing identifier DEFINED expr
       ;

relop:   LE {$$=LE;}
     |   GE {$$=GE;}
     |   LT {$$=LT;}
     |   GT {$$=GT;}
     |   ASSIGN {$$=ASSIGN;}
     |   EQ {$$=EQ;}
     |   NE {$$=NE;}
     ;

equation: expr ASSIGN expr { $$ = new opNode(ASSIGN, $1, $3); }
        | expr LT expr { $$ = new opNode(LT, $1, $3); }
        | expr LE expr { $$ = new opNode(LE, $1, $3); }
        | expr GT expr { $$ = new opNode(GT, $1, $3); }
        | expr GE expr { $$ = new opNode(GE, $1, $3); }
        | expr EQ expr { $$ = new opNode(EQ, $1, $3); }
        ;

cnstr:   MAXIMIZE ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON expr {
            current_model->symbol_table.defineSymbol(SymbolTable::ST_OBJ, $2);
            add_obj_to_model(MAXIMIZE, $2, $3, $7);     
            if ($3) rem_indexing($3);
            $$=$2;
         }
     |   MINIMIZE ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON expr {
            current_model->symbol_table.defineSymbol(SymbolTable::ST_OBJ, $2); 
            add_obj_to_model(MINIMIZE, $2, $3, $7);     
            if ($3) rem_indexing($3);
            $$=$2;
         }
     |   SUBJECTTO ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt COLON equation { 
            current_model->symbol_table.defineSymbol(SymbolTable::ST_CONS, $2); 
            add_cons_to_model($2, $3, $7);
            if ($3) rem_indexing($3);
            $$=$2;
         }
     ;

//csattributes_opt: /* empty */ {$$=NULL;}
//                 | csattributes {$$ = $1;}
//                 ;


//csattributes: csattribute {
//                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
//             | csattributes COMMA csattribute{
//              $$ = addItemToListOrCreate(COMMA, $1, $3);
//        }
//             ;

//csattribute: STAGES setexpression {
//               $$ = NULL;
//          stages = $2;
//             }
//           ;

indexing_opt: /* empty */ {$$=NULL;}
            | indexing {$$=$1;}
            ;

indexing:   LBRACE setexpr_list COLON lexpr RBRACE {
               opNode *tmp = new opNode(LBRACE, new opNode(COLON, $2, $4));
               $$ = new opNodeIx(tmp);
               delete tmp;
            }
        |   LBRACE setexpr_list RBRACE {
               opNodeIx *tmp = new opNodeIx(new opNode(LBRACE, $2));
               $$=tmp;
            }
        ;

/* FIXME: ID IN setexpression defines a dummy variable (?)
   -> have this as a separate construct
   -> how to deal with dummy variables? */
setexpr_list:  setexpr_item
            |  setexpr_list COMMA setexpr_item{
                  if ($1->opCode==COMMA){
                     $$ = $1->push_back($3);
                  }else{
                     $$ = new opNode(COMMA, $1, $3);
                  }
               }
            ;

setexpr_item : setexpression
             | dummy_member IN setexpression{
                  $$ = new opNode(IN, $1,$3);
               }
             ;

dummy_member : ID {$$=new IDNode($1);}
             | LBRACKET ID COMMA ID RBRACKET {
                  opNode *tmp = new opNode(LBRACKET, 
                     new opNode(COMMA, new IDNode($2), new IDNode($4)));
                  $$ = tmp;
               }
             ;

lexpr:   expr
     |   LBRACKET lexpr RBRACKET {
            $$ = new opNode(LBRACKET, $2); }
     |   equation
     ;

setdef:  SET ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt setattributes_opt {
            current_model->symbol_table.defineSymbol(SymbolTable::ST_SET, $2); 
            add_set_to_model($2, $3, $6);
            if (GlobalVariables::logParseModel) 
               cout << "$6 = " << $6 << "\n";
            if (GlobalVariables::logParseModel)
               cout << "$5 = " << $5 << "\n";
            if ($3) rem_indexing($3);
            //$$=$2; 
         }
      ;

/* qualifier can be public/random: is this redundant? */
paramdef:   qualifier PARAM ID indexing_opt {
               if ($4) add_indexing($4);
            } stochattr_opt paramattributes_opt {
               current_model->symbol_table.defineSymbol(
                  SymbolTable::ST_PARAM, $3); 
               add_param_to_model($3, $4, $7);
               if ($4) rem_indexing($4);
               //$$=$2; 
            }
        ;

vardef:  VAR ID indexing_opt {
            if ($3) add_indexing($3);
         } stochattr_opt varattributes_opt {
            current_model->symbol_table.defineSymbol(SymbolTable::ST_VAR, $2); 
            add_var_to_model($2, $3, $6);
            if ($3) rem_indexing($3);
            //$$=$2; 
         }
      ;



qualifier:  /* empty */
         |  PUBLIC
         |  RANDOM
         ;

/* these are SET definitions */

setattributes_opt:   /* empty */ {$$=NULL;}
                 | setattributes {$$=$1;}
                 ;

setattributes: setattribute {$$=$1;}
             | setattributes setattribute {
                  if ($2==NULL){
                     $$ = $1;
                  }else{
                     if ($1==NULL){
                        $$ = new opNode(' ', $2);
                     }else{
                        if ($1->opCode==' '){
                           $$ = $1->push_back($2);
                        }else{
                           $$ = new opNode(' ', $1, $2);
                        }
                     }
                  }
               }
             ;

setattribute:  DIMEN INT_VAL {
                  $$ = new opNode(DIMEN, new ValueNode<long>(*$2));
               }
            |  WITHIN setexpression {
                  $$ = new opNode(WITHIN, $2);
               }
            | DEFINED setexpression {
                  $$ = new opNode(DEFINED, $2);
               }
            |  DEFAULT setexpression {
                  $$ = new opNode(DEFAULT, $2);
               }
            |  ORDERED { $$ = new opNode(ORDERED); }
            ;

paramattributes_opt: /* empty */ { $$ = NULL; }
                   | paramattributes { $$ = $1; }
                   ;

paramattributes:  paramattribute {
                     if ($1==NULL) {$$ = NULL;}
                     else{$$ = new opNode(COMMA, $1);}
                  }
               |  paramattributes COMMA paramattribute {
                     if ($3==NULL){
                        $$ = $1;
                     }else{
                        if ($1==NULL){
                           $$ = new opNode(COMMA, $3);
                        }else{
                           $$ = $1->push_back($3);
                        }
                     }
                  }
               ;

paramattribute:   BINARY {$$ = new opNode(BINARY);}
              |   INTEGER {$$ = new opNode(INTEGER);}
              |   SYMBOLIC {$$ = new opNode(SYMBOLIC);}
              |   relop expr {$$ = new opNode($1, $2);}
              |   IN setexpression {$$ = new opNode(IN, $2);}
              |   ASSIGN expr {$$ = new opNode(ASSIGN, $2);}
              |   DEFAULT expr {$$ = new opNode(DEFAULT, $2);}
              ;

stochattr_opt: /* empty */ {$$ = NULL;}
             | DETERMINISTIC {
                  // check that this is in a stochastic model
                  if (!is_stoch_model){ 
                     cerr << "Syntax Error: keyword 'DETERMINISTIC' can only"
                        "be used in stochastic blocks\n";
                     exit(1);
                  }
                  is_deterministic_loc = true;
                  $$ = NULL;
               }
             | STAGES setexpression {
                  // check that this is in a stochastic model
                  if (!is_stoch_model){ 
                     cerr << "Syntax Error: keyword 'STAGES' can only be used"
                        "in stochastic blocks\n";
                     exit(1);
                  }
                  $$ = NULL;
                  stages_loc = $2;
               }
             ;

varattributes_opt:   /* empty */ {$$=NULL;}
                 |   varattributes {$$ = $1;}
                 ;


varattributes: varattribute {
                  $$ = addItemToListOrCreate(COMMA, NULL, $1);}
             | varattributes COMMA varattribute {
                  $$ = addItemToListOrCreate(COMMA, $1, $3);
               }
             ;

/* FIXME: what to do about the ID in the last rule ? */
varattribute:  BINARY {$$ = new opNode(BINARY);}
            |  INTEGER {$$ = new opNode(INTEGER);}
            |  SYMBOLIC {$$ = new opNode(SYMBOLIC);}
            |  LE expr {$$ = new opNode(LE, $2);}
            |  GE expr {$$ = new opNode(GE, $2);}
            |  DEFINED expr {$$ = new opNode(DEFINED, $2);}
            |  ASSIGN expr {$$ = new opNode(ASSIGN, $2);}
            |  DEFAULT expr {$$ = new opNode(DEFAULT, $2);}
         //| COEFF indexing_opt constraint expr
         //| COVER indexing_opt constraint expr
         //| OBJ indexing_opt objective expr
            |  IN setexpression {$$ = new opNode(IN, $2);}
            |  SUFFIX ID expr {$$ = new opNode(SUFFIX, $3);}
            ;

/* this is anything that evaluates to a set */
setexpression: LBRACE expr_list RBRACE  {$$ = new ListSet($2);}
             | identifier    /* already defined identifier */ 
             | setexpression bsetop setexpression {
                  $$ = new CompositeSet($2, $1, $3);
               }
             | setexpression ubsetop setexpression {
                  $$ = new CompositeSet($2, $1, $3);
               }
             | ubsetop indexing setexpression {
                  cerr << "FIXME: ubsetop indexing setexpression\n";
                  exit(2);
               }
             | expr DOTDOT expr {
                  $$ = new SimpleSet($1, $3);
               }
             | SETOF indexing identifier {
                  cerr << "FIXME: SETOF\n";
                  exit(2);
               }
             //FIXME: | if lexpr then sexpr else sexpr
             | LBRACKET setexpression RBRACKET {
                  $$ = $2;
               }
             //FIXME: | interval
             //FIXME: | infinite-set
             //FIXME: | indexing
             ;

bsetop:  DIFF     { $$ = DIFF; }
      |  SYMDIFF  { $$ = SYMDIFF; }
      |  CROSS    { $$ = CROSS; }
      ;

ubsetop: UNION    { $$ = UNION; }
      |  INTER    { $$ = INTER; }
      ;
      

/* Identifier is any quotation of a predefined object:
    RoutComm[j].Flow[k-3*j, k]#
   An iditem is simply a tree of opNodes that serve as an identifier.
   An 'identifer' is an opNode of type IDREF or IDREFM
*/
identifier: iditem {
               /* this is a simple identifier in global context */
               $$ = find_var_ref_in_context(current_model, $1);
            }
          | identifier DOT iditem {
               /* identifier sets the context for the iditem:
                  The result of this is either a context setting or a
                  complete description of a variable.

                  Can implement this by simply adding context and argument lists
                
                  A variable reference should be represented internally as a
                  pointer to the referenced object in the model list
                  and a pointer to the list of arguments

                  This can be represented as a opNode with
                  ->opCode = ID;
                  ->nval = # of arguments
                  ->values[0] = pointer to entity in model list
                  ->values[1 - n] = arguments 

                  CONTEXT: iditems can be interpreted in two different contexts
                  1) is the global context (i.e. referring from the model
                     part that is currently defined)
                  2) is a local context that can be set by preceeding bits
                     of a dot'd expression. If a dot'd expression is 
                     parsed the flag 'local_context' should be set and 
                     'local_context' should be set to the current local
                     context. 
                  a context is expressed as a pointer to a model entity
               */
       
               /* identifier sets the context for the idem */
               /* this only works if the identifier is actually a reference 
                  to a submodel */

               if ($1->opCode!=IDREFM){
                  cerr << "Attempting to use dot specifier for something "
                     "not an object:\n " << *($1) << "\n";
                  exit(1);
               }
               local_context = (AmplModel*)(((opNodeIDREF*)$1)->ref)->other;

               if (GlobalVariables::logParseModel) {
                  cout << "Trying to merge \n identifier "<< *($1);
                  cout << " and iditem " << *($3) << "\n";
               }
               $$ = find_var_ref_in_context(local_context, $3);

               /* merge argument lists */
               $$->merge(*($1));
            }
          ;




iditem:  ID {                               /* simple identifier */
            $$=new IDNode($1);
         }
      |  ID LSBRACKET expr_list RSBRACKET { /* subscripted id'fier */
            if (GlobalVariables::logParseModel) 
               cout << print_opNodesymb($3) << "\n";
            $$ = new opNode(LSBRACKET, new IDNode($1), $3);
            //printf("%s\n", print_opNodesymb($$));
         }
      |  ID LBRACKET INT_VAL SEMICOLON expr_list RBRACKET {
            // This is of the type xh(-1,i) which is xh[i] at a previous stage
            // the ancestor information is conveyed by an ID opNode with 
            // two arguments, where the second argument is the ancestor
            // $3 is (long int*) => change its sign
            *$3 = -(*$3);
            opNode *nd = new IDNode($1, *$3);
            $$ = new opNode(LSBRACKET, nd, $5);
         }      
      |  ANCESTOR LBRACKET INT_VAL RBRACKET DOT iditem {
            // the same as above, just different syntax "ancestor(1).xh[i]"
            // => need to change the ID node in iditem into a binary node
            //    with INT_VAL ($3) as the second argument
   
            // iditem is either an ID or a LSBRACKET node
            opNode *node = $6;
            IDNode *idnode;
            if (node->opCode==LSBRACKET) {
               idnode = (IDNode*) *(node->begin());
            } else {
               idnode = (IDNode *) node;
            }
            assert(idnode->opCode==ID);
            assert(idnode->stochparent==0);
            idnode->stochparent = *$3;
            $$ = $6;
         }
      ;

/* expr_list: is a comma separated list of expr's */
/* used as argument list to functions 
   RETURNS: 
   *opNode of type COMMA representing a linked list of items
*/

expr_list:  expr {
               $$ = new opNode(COMMA, $1);
            }
         |  expr_list COMMA expr {      /* add item to list */
               /* epxr_list could be a simple node or a comma separated
                  list (CSL) already 
                  - if it is a simple node, need to start a comma separated list
                  - if it is a CSL need to add an item to it
               */
               //printf("join nodes >%s< >%s<\n",
               //print_opNode($1),print_opNode($3));
               assert($1->opCode==COMMA);
               $$ = $1->push_back($3);
            }
         ;

expr: value
    | LBRACKET expr_list RBRACKET { $$ = new opNode(LBRACKET, $2); }
    | expr '+' expr { $$ = new opNode('+', $1, $3); }
    | expr '-' expr { $$ = new opNode('-', $1, $3); }
    | '-' expr { $$ = new opNode('-', $2); }
    | expr '*' expr { $$ = new opNode('*', $1, $3); }
    | expr '/' expr { $$ = new opNode('/', $1, $3); }
    | expr POWER expr { $$ = new opNode(POWER, $1, $3); }
    | expr ELLIPSE expr { $$ = new opNode(ELLIPSE, $1, $3); }
    | expr LOGICAL_OR expr { $$ = new opNode(LOGICAL_OR, $1, $3); }
    | expr LOGICAL_AND expr { $$ = new opNode(LOGICAL_AND, $1, $3); }
    | '!' expr { $$ = new opNode('!', $2); }
    | reduction_op indexing {add_indexing($2);} expr { 
         /* reduction operator: do we need to keep track of the ID of the
            dummy variable(s)? */
         $$ = new opNode((int)$1, $2, $4);
         rem_indexing($2);
      }
    | IF lexpr THEN expr { $$ = new opNode(IF, $2, $4); }
    | IF lexpr THEN expr ELSE expr { $$ = new opNode(IF, $2, $4, $6); }
    | FIRST LBRACKET setexpression RBRACKET { $$ = new opNode(FIRST, $3); }
    | LAST LBRACKET setexpression RBRACKET { $$ = new opNode(LAST, $3); }
    | EXPECTATION LBRACKET expr_list RBRACKET { 
         //$$ = new opNode(EXPECTATION, new opNode(LBRACKET, $3));}
         $$ = new opNode(EXPECTATION, $3);
      }
    | func LBRACKET expr_list RBRACKET { /* function definition */
         $$ = new opNode($1, new opNode(LBRACKET, $3));
      }
    ;

func :   ORD { $$=ORD; }
     |   CARD { $$=CARD; }
     ;

reduction_op:  SUM { $$=SUM; }
            |  MAX { $$=MAX; }
            |  MIN { $$=MIN; }
            |  PROD { $$=PROD; }
            ;

value:   INT_VAL {
            $$=new ValueNode<long>(*$1);
         }
     |   FLOAT_VAL { 
            $$=new ValueNode<double>(*$1);
         }
     |   identifier { 
            $$=new opNode(0, $1);
         }
     |   INFINITY { 
            $$ = new opNode(INFINITY);
         }
     |   STAGE { 
            $$ = new opNode(STAGE);
         }
     |   NODE { 
            $$ = new opNode(NODE);
         }
     ;

/* ----------------------------------------------------------------------------
 stuff for the data file reader to follow
---------------------------------------------------------------------------- */
//data_statements: /* empty */
//          | data_statements data_statement 
//          ;
//
//data_statement: data_paramdef SEMICOLON
//              | data_setdef SEMICOLON
//              ;
//
//data_setdef: SET ID ASSIGN setelements
//
//setelements: /* empty */
//           | setelements setelement
//           ;
//
//setelement: ID
//         
//data_paramdef: PARAM ID ASSIGN valuelist
//
//valuelist: value
//         | valuelist value
//         ;
%%

void yyerror(char *s) {
   cerr << "MODEL: " << s << " on line " << yylineno << "\n";
   //fprintf(stderr, "%s\n", s);
}


/* ----------------------------------------------------------------------------
yywrap
---------------------------------------------------------------------------- */
/* not sure if this is correct, found this somewhere on the internet
   should open the data file and somehow tell the parser to carry on 
   reading in "data mode"

 */
int yywrap(void) {
   return 1;
}

void analyseOptions(int argc, char **argv){
   int i;
   int found =0;
   for (i=1;i<argc;i++){
      if (strcmp(argv[i], "-d")==0){
         yydebug = 1;
      }else{
         if (found==0){
            // first proper argument is the model file to read
            GlobalVariables::modelfilename = argv[i];
            found++;
         }else{
            // next one is data file
            GlobalVariables::datafilename = argv[i];
         }
      }
   }
   // now echo the options
   if (yydebug==1){
      cout << "OPTIONS: debug mode\n";
   }
   if (GlobalVariables::modelfilename){
      cout << "OPTIONS: model file: " << GlobalVariables::modelfilename << "\n";
   }else{
      cout << "OPTIONS: read model from stdout\n";
   }
   if (GlobalVariables::datafilename){
      cout << "OPTIONS: data file: " << GlobalVariables::datafilename << "\n";
   }else{
      cout << "OPTIONS: read data from 'global.dat'\n";
   }
   return;
}

/* ----------------------------------------------------------------------------
main
---------------------------------------------------------------------------- */
int main(int argc, char **argv) {
   int errcode;
   GlobalVariables::modelfilename = NULL;
   GlobalVariables::datafilename = "global.dat";

   analyseOptions(argc, argv);
   if (GlobalVariables::modelfilename){
      yyin = fopen(GlobalVariables::modelfilename, "r");
      if (yyin==NULL){
         cerr << "ERROR: file '" << GlobalVariables::modelfilename <<
            "' not found\n";
         exit(1);
      }
   }

   /* make sure dir '/tmp' for temporary files exists */
   createSubdirTmpIfNotExist();
   errcode = chdir("tmp");
   if (errcode){
      cerr << "Could not change working directory to 'tmp/'\n";
      cerr << "Cannot continue\n";
      exit(1);
   }

   /* setup the root of the model tree */
   //AmplModel::root = (AmplModel*)calloc(1, sizeof(AmplModel));
   AmplModel::root = new AmplModel("root");
   current_model = AmplModel::root;
   is_stoch_model = false;
   is_deterministic_loc = false;
   stages_loc = NULL;
   is_deterministic_glo = false;
   stages_glo = NULL;

   errcode = yyparse();
   if (errcode!=0){
      cerr << "yyparse returns " << errcode << "\n";
      exit(1);
   }

   // change working directory back to original for the parsing of data file
   errcode = chdir("..");
   if (errcode){
      cerr << "Could not change working directory to '../'\n";
      cerr << "Cannot continue\n";
      exit(1);
   }
   
   if (GlobalVariables::datafilename){
      //if (0){
      fclose(yyin);
      yyin = fopen(GlobalVariables::datafilename,"r");
      if (yyin==NULL){
         cerr << "ERROR: Data file '" << GlobalVariables::datafilename <<
            "' not found\n";
         exit(1);
      }
     
      parse_data(current_model, GlobalVariables::datafilename);
     
   }

   // change working directory back to tmp/ for processing model
   errcode = chdir("tmp");
   if (errcode){
      cerr << "Could not change working directory to 'tmp/'\n";
      cerr << "Cannot continue\n";
      exit(1);
   }

   do_stuff(current_model);

   return 0;
}

/* ----------------------------------------------------------------------------
begin_model
---------------------------------------------------------------------------- */
void
begin_model(char *name, opNode *indexing) {
  AmplModel *new_mod = new AmplModel;
  model_comp *newmc;
  
  cout << "Start Model: " << name << "\n";
  new_mod->name = strdup(name);

  /* FIXME: include attrib in definition */
  newmc = new model_comp(name, TMODEL, indexing, NULL);
  newmc->other = new_mod;

  new_mod->node = newmc;            /* add pointer-to-node to the model */
  addCompToModel(current_model, newmc);   
 
  new_mod->setGlobalName();    
  /* and change current model */
  current_model = new_mod;
}

/* ----------------------------------------------------------------------------
begin_smodel
---------------------------------------------------------------------------- */
void
begin_smodel(char *name, opNode *indexing, opNode *stochsets) {
   StochModel *new_mod;
   model_comp *newmc;
  
   if (stochsets->opCode!=COMMA || stochsets->nchild()!=4){
      cerr << "Syntax error in Stochastic Block definition: \n";
      cerr << " 'USING' needs 4 parameters \n";
      exit(1);
   }

   if (GlobalVariables::logParseModel)
      cout << "Start Stochastic Model: " << name << "\n";

   new_mod = new StochModel((opNode*)stochsets->values[0], // stages
      (opNode*)stochsets->values[1], // nodes
      (opNode*)stochsets->values[2], // anc
      (opNode*)stochsets->values[3], // prob
      current_model); 

   new_mod->name = strdup(name);
  
   /* Fixme: include attrib in definition */
   newmc = new model_comp(name, TMODEL, indexing, NULL);
   newmc->other = new_mod;

   new_mod->node = newmc;            /* add pointer-to-node to the model */
   addCompToModel(current_model, newmc);
 
   new_mod->setGlobalName();    
   /* and change current model */
   current_model = new_mod;
   is_stoch_model = true;
}

/* ----------------------------------------------------------------------------
end_model
---------------------------------------------------------------------------- */
void
end_model() {
   current_model = current_model->parent;
}

/* ----------------------------------------------------------------------------
end_smodel
---------------------------------------------------------------------------- */
void
end_smodel(){
  // current_model is a StochModel -> convert this into a tree a FlatModels

  // this is the model_comp pointing to the StochModel
  model_comp *mc = current_model->node; 
  
  // point that to the expanded flat model tree
  mc->other = ((StochModel*)current_model)->expandToFlatModel();

  // and change the name of the model_comp of this model to the name of the 
  // new (AmplModel) model. 
  // (this is a concatenation of the StochModel name and the name of the 
  // first stage)
  mc->id = strdup(((StochModel*)mc->other)->name);

  // and go back to the parent 
  current_model = current_model->parent;
  is_stoch_model = false;
}

/* ----------------------------------------------------------------------------
add_set_to_model
---------------------------------------------------------------------------- */
void
add_set_to_model(char *id, opNode *indx, opNode *attrib){
   model_comp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TSET, indx, attrib);
   }else{
      newmc = new model_comp(id, TSET, indx, attrib);
   }
   addCompToModel(current_model, newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
}

/* ----------------------------------------------------------------------------
add_obj_to_model
---------------------------------------------------------------------------- */
void
add_obj_to_model(int token, char *id, opNode *indx, opNode *attrib){
   model_comp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TMIN, indx, attrib);
   }else{
      newmc = new model_comp(id, TMIN, indx, attrib);
   }
   if (token==MAXIMIZE) newmc->type = TMAX;
   //newmc->ismin = (token==MINIMIZE);

   addCompToModel(current_model, newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

}

/* ----------------------------------------------------------------------------
add_cons_to_model
---------------------------------------------------------------------------- */
void
add_cons_to_model(char *id, opNode *indx, opNode *attrib){
   model_comp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TCON, indx, attrib)   ;
   }else{
      newmc = new model_comp(id, TCON, indx, attrib)   ;
   }
   addCompToModel(current_model, newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);

   /*
   if (current_model->cons==NULL){
      current_model->cons = newmc;
   }else{
      model_comp *last = current_model->cons;
      while(last->next!=NULL) last = last->next;
      last->next = newmc;
   }
   current_model->n_cons++;
   */
}

/* ----------------------------------------------------------------------------
add_var_to_model
---------------------------------------------------------------------------- */
void
add_var_to_model(char *id, opNode *indx, opNode *attrib){
   model_comp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TVAR, indx, attrib);
   }else{
      newmc = new model_comp(id, TVAR, indx, attrib);
   }
   addCompToModel(current_model, newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
}


/* ----------------------------------------------------------------------------
add_param_to_model
---------------------------------------------------------------------------- */
void
add_param_to_model(char *id, opNode *indx, opNode *attrib){
   model_comp *newmc;
   if (is_stoch_model){
      newmc = new StochModelComp(id, TPARAM, indx, attrib);
   }else{
      newmc = new model_comp(id, TPARAM, indx, attrib);
   }
   addCompToModel(current_model, newmc);
   if (is_stoch_model) addStochInfo((StochModelComp*)newmc);
    
   /*
   if (current_model->params==NULL){
      current_model->params = newmc;
   }else{
      model_comp *last = current_model->params;
      while(last->next!=NULL) last = last->next;
      last->next = newmc;
   }
   current_model->n_params++;
   */
}

/* ----------------------------------------------------------------------------
findKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

opNode *
findKeywordinTree(opNode *root, int oc)
{
   if (root->opCode==oc) return root;

   opNode *found, *res;
   found = NULL;
   for(opNode::Iterator i=root->begin(); i!=root->end(); ++i) {
      res = findKeywordinTree((opNode*)*i, oc);
      if(res && found) {
         cerr << "Found keyword " << oc << "at least twice in " << root << "\n";
         exit(1);
      }
      found = res;
   }
   return found;
}

/* ----------------------------------------------------------------------------
countKeywordinTree
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and counts the number of keyword 'oc'
   nodes in the tree */


int
countKeywordinTree(opNode *root, int oc)
{
   if (root->opCode==oc) return 1;
   
   int ret = 0;
   for(opNode::Iterator i=root->begin(); i!=root->end(); ++i) {
      ret += countKeywordinTree((opNode*)*i, oc);
   }
   return ret;
}

/* ----------------------------------------------------------------------------
findIDinTreeAndAddToList(tmpnode->values[0], ldummy);
---------------------------------------------------------------------------- */
/* this routine traverses down the tree and returns the top most reference to 
   the keyword in the Tree */

void
findIDinTreeAndAddToList(opNode *node, char  **list, int *nlist)
{
   int i;

   if (node->opCode==ID){
      bool found = false;
      /* add the variable name to the list */
      /* should check that the name is not on the list already */
      if (GlobalVariables::logParseModel)
         cout << "Consider to add name " << (opNode*)*node->begin() <<
            " to list\n";
      for(i=0;i<(*nlist);i++){
         if (strcmp((const char*)*(node->begin()), list[i])==0)
         found = true;
      }

      if (!found){
         list[*nlist] = (char*)*(node->begin());
         (*nlist)++;
      }
      return;
   }
   for (opNode::Iterator i=node->begin(); i!=node->end(); ++i){
      findIDinTreeAndAddToList((opNode*)*i, list, nlist);
   }
  
}

/* ---------------------------------------------------------------------------
find_var_ref_in_context
---------------------------------------------------------------------------- */
/** This routine does the work of putting together dot'd variable names
 *  'root' is a opNode of type ID that points to the left hand part
 *  of the dot'd expression parsed so far. 'ref' is the new part that
 *  should be added.
 *
 * @param ref A pointer to an expression that evaluates to a model_comp
 *            this can be given by an ID a dotted expression ID.ID
 *            or a reference to a parent stage (in StochProg) such as 
 *            ID(-1;...).
 *            It can also carry an indexing expressinon ID[.,.,.] in
 *            which case the indexing is attached to the returned IDREF node
 * @param context A pointer to the current AmplModel that defines the scope
 *                in which the ID expressions should be resolved
 * @return An opNode of type IDREF that points to the correct model_comp
 * @bug Should return an opNodeIDREF* 
 *
 *  An opNode of type IDREF looks like this
 *       ->opCode = IDREF;
 *       ->nval = # of arguments
 *       ->values[0] = pointer to entity in model list
 *       ->values[1 - n] = arguments 
 */
opNode*
find_var_ref_in_context(AmplModel *context, opNode *ref)
{
   /* 'ref' is an opNode representing an iditem. 
      This can be either
      - a ID node where values[0] simply points to a name
      - an ID node which is actually opNodeID and has stochparent set
      - a LSBRACKET node, where values[0] is ID and values[1] is CSL
      in the second case the CSL should be added as further arguments
      to the resulting IDREF node

   */
  
   /* returns: pointer */
   opNode *tmp, *argNode;
   IDNode *idNode;
   opNodeIDREF *ret;
   int stochparent=0;

   /* and now scan through the whole of the local context to see if we 
      find any matches */
   /* the local context is 
       - all vars
       - all constraints
       - all objectives
       - all sets
       - all parameters
       - all submodels
       - all temporary variables (this list needs to be set up somewhere)
   */
  
   // split the expression 'ref' into an id part and an argument list
   if (GlobalVariables::logParseModel)
      cout << "find_var_ref_in_context: " << ref << "\n";

   if (ref->opCode==ID){
      idNode = (IDNode *)ref;
      argNode = NULL;
   }else{
      assert(ref->opCode==LSBRACKET||ref->opCode==LBRACKET);
      opNode::Iterator i = ref->begin();
      idNode = (IDNode*)*i;
      argNode = *(++i);
      assert(idNode->opCode==ID);
      assert(argNode->opCode==COMMA);
   }

   // Test if this ID node is actually of type opNodeID and if so remember
   // the value of stochparent
   {
      if (idNode->stochparent!=0){
         // there is an extra argument, which is the stochparent
         stochparent = idNode->stochparent;
      }
   }

   if (GlobalVariables::logParseModel) 
      cout << "--> search for matches of " << idNode->name << "\n";
 
   // see if this matches a dummy variable
   tmp = find_var_ref_in_indexing(idNode->name.c_str());
   if (tmp) {
      if (GlobalVariables::logParseModel) 
         cout << idNode->name << " is matched by dummy var in " << *tmp << "\n";
      return ref;
   }

   // try to find a match in the local context
   ret = find_var_ref_in_context_(context, idNode);

   if (argNode){
      if (GlobalVariables::logParseModel)
         cout << "Adding argument list to node: " << *argNode << "\n";
      free(idNode->values); // jdh - what does this do?
      ret->values = argNode->values;
      ret->nval = argNode->nval;
      if (ref->opCode==LBRACKET){
         // this is old code to deal with ancestor(1).ID declarations. To go
         cerr << "Executing old code to deal with ancestor(1).ID "
            "declarations\n";
         exit(1);

         // This is a reference indexed by '(..)'. In this case we are in
         // a stoch block and the first argument refers to the stage
         //      ret->stochrecourse = (opNode*)ret->values[0];
         //for(int i=1;i<ret->nval;i++){
         //ret->values[i-1] = ret->values[i];
         //}
         //ret->nval--;
      }
      argNode->values=NULL;
      argNode->nval = 0;
   } else {
      ret->nval = 0;
   }
  
   ret->stochparent = stochparent;
   return ret;
}

opNodeIDREF*
find_var_ref_in_context_(AmplModel *context, IDNode *ref)
{
   model_comp *thismc;
   opNodeIDREF *ret;
  
   for(list<model_comp*>::iterator p = context->comps.begin();
         p!=context->comps.end();p++){
      thismc = *p;
      if (strcmp(ref->name.c_str(), thismc->id)==0){
         /* this is a match */
         if (GlobalVariables::logParseModel){
            cout << "Found Match: " << ref->name << " refers to ";
            cout << nameTypes[thismc->type] << "\n";
            cout << "    " << thismc->id << "\n";
            cout << "       " << *(thismc->indexing) << "\n";
            cout << "       " << *(thismc->attributes) << "\n";
         }

         ret = new opNodeIDREF();
         ret->ref = thismc;
         ret->opCode = IDREF;
         if (thismc->type==TMODEL){
            ret->opCode = IDREFM;
         }
         return ret;
      }
      //thismc = thismc->next;
   }

  
   //thismc = context->vars;
   //for(i=0;i<context->n_vars;i++){
   //  if (strcmp(name, thismc->id)==0){
   //    /* this is a match */
   //    printf("Found Match: %s refers to variable\n",name);
   //    printf("    %s\n",thismc->id);
   //    printf("       %s\n",print_opNode(thismc->indexing));
   //    printf("       %s\n",print_opNode(thismc->attributes));
   //    ref->values[0] = (void*)thismc;
   //    ref->opCode = IDREF;
   //    return ref;
   //  }
   //  thismc = thismc->next;
   //}
   //thismc = context->cons;
   //for(i=0;i<context->n_cons;i++){
   //  if (strcmp(name, thismc->id)==0){
   //    /* thismc is a match */
   //    printf("Found Match: %s refers to constraint\n",name);
   //    printf("    %s\n",thismc->id);
   //    printf("       %s\n",print_opNode(thismc->indexing));
   //    printf("       %s\n",print_opNode(thismc->attributes));
   //    ref->values[0] = (void*)thismc;
   //    ref->opCode = IDREF;
   //    return ref;
   //  }
   //  thismc = thismc->next;
   //}
   //thismc = context->sets;
   //for(i=0;i<context->n_sets;i++){
   //  if (strcmp(name, thismc->id)==0){
   //    /* this is a match */
   //    printf("Found Match: %s refers to set\n",name);
   //    printf("    %s\n",thismc->id);
   //    printf("       %s\n",print_opNode(thismc->indexing));
   //    printf("       %s\n",print_opNode(thismc->attributes));
   //    ref->values[0] = (void*)thismc;
   //    ref->opCode = IDREF;
   //    return ref;
   //  }
   //  thismc = thismc->next;
   //}
   //thismc = context->params;
   //for(i=0;i<context->n_params;i++){
   //  if (strcmp(name, thismc->id)==0){
   //    /* this is a match */
   //    printf("Found Match: %s refers to parameter\n",name);
   //    printf("    %s\n",thismc->id);
   //    printf("       %s\n",print_opNode(thismc->indexing));
   //    printf("       %s\n",print_opNode(thismc->attributes));
   //    ref->values[0] = (void*)thismc;
   //    ref->opCode = IDREF;
   //    return ref;
   //  }
   //  thismc = thismc->next;
   //}
   //thism = context->submodels;
   //for(i=0;i<context->n_submodels;i++){
   //  if (strcmp(name, thism->name)==0){
   //    /* this is a match */
   //    printf("Found Match: %s refers to submodel\n",name);
   //    printf("    %s\n",thism->name);
   //    //printf("       %s\n",print_opNode(thism->indexing));
   //    //printf("       %s\n",print_opNode(this->attributes));
   //    ref->values[0] = (void*)thism;
   //    ref->opCode = IDREFM;
   //    return ref;
   //  }
   //  thism = thism->next;
   //}

   /* need also to look through parent model */
   if (context->parent){
      opNodeIDREF *match = find_var_ref_in_context_(context->parent, ref);
      return match;
   }

   /* need also to look through list of local variables */

   cerr << "Could not find ref " << ref->name << " in context\n";
   exit(1);
}


/* ---------------------------------------------------------------------------
find_var_ref_in_indexing
---------------------------------------------------------------------------- */
/* scan through the current set of active indexing expressions and see if
   any of them define the dummy variable  given by 'name' 

   IN: 
    char *name                 the name of identifier to look for
    
    int n_indexing             the currently active indexing expressions
    opNode *list_of_indexing
   RETURN:
    The Indexing expression in which the name occurs 
    (or NULL if there is no match)
                                                                      */

opNode *
find_var_ref_in_indexing(const char *const name)
{
   int i;
   opNodeIx *tmp;
   opNode *ret = NULL;

   for(i=0;i<n_indexing;i++){
      /* have a look at all the indexing expressions */
      /* an indexing expression is a '{' node followed by a 'Comma' node */
      tmp = list_of_indexing[i];
      if (tmp!=NULL){
         tmp->splitExpression();
         ret = tmp->hasDummyVar(name);
         if (ret) return ret;
       
#if 0
         assert(tmp->opCode==LBRACE);
         tmp = (opNode*)tmp->values[0];
         if (tmp->opCode==COLON) tmp = (opNode*)tmp->values[0];
         /* this should now be a comma separated list */
         if (tmp->opCode==COMMA){
            for(j=0;j<tmp->nval;j++){
               tmp2 = findKeywordinTree((opNode*)tmp->values[j], IN);
               /* everything to the left of IN is a dummy variables */
               if (tmp2){
                  tmp2 = (opNode*)tmp2->values[0];
                  assert(tmp2->opCode==ID);
                  if (GlobalVariables::logParseModel)
                     printf("Found dummy variable: %s\n",tmp2->values[0]);
                  if (strcmp(name, (const char*)tmp2->values[0])==0)
                     ret = (opNode*)tmp->values[j];
     
               }
            }
         }else{
            /* if this is not a comma separated list, then look directly */
            char *tmpbuf1 = print_opNode(tmp);
            char *tmpbuf2 = print_opNodesymb(tmp);
            if (GlobalVariables::logParseModel){
               printf(">%s\n", tmpbuf1);
               printf(">%s\n", tmpbuf2);
            }
            free(tmpbuf1);
            free(tmpbuf2);
            tmp2 = findKeywordinTree(tmp, IN);
            /* everything to the left of IN is a dummy variables */
            if (tmp2){
               tmp2 = (opNode*)tmp2->values[0];
               assert(tmp2->opCode==ID||tmp2->opCode==COMMA);
               if (GlobalVariables::logParseModel)
                  printf("Found dummy variable: %s\n",tmp2->values[0]);
               if (strcmp(name, (const char*)tmp2->values[0])==0)
                  ret = tmp;
            }
         }
#endif
      }
   }
   return ret;
}

/* ------------------------------------------------------------------------
add_indexing/rem_indexing
-------------------------------------------------------------------------- */
void 
add_indexing(opNodeIx *indexing){
   list_of_indexing[n_indexing] = indexing;
   if (GlobalVariables::logParseModel){
      char *tmp2 = print_opNodesymb(indexing);
      cout << "add indexing expression to list: " << *indexing << "\n";
      cout << "Symbolic indexing: " << tmp2 << "\n";
      cout << "length of indexing now: " << n_indexing+1 << "\n";
      free(tmp2);
   }
   n_indexing++;
}

void
rem_indexing(opNodeIx *indexing){
   if (indexing){
      assert(indexing==list_of_indexing[n_indexing-1]);
      if (GlobalVariables::logParseModel) 
         cout << "rem indexing expression to list: " << *indexing << "\n";
   }
   if (GlobalVariables::logParseModel) 
      cout << "length of indexing now: " << n_indexing-1 << "\n";
   n_indexing--;
}

/* ---------------------------------------------------------------------------
Stochastic model helper functions
---------------------------------------------------------------------------- */
void 
addStochInfo(StochModelComp *newmc)
{
   newmc->is_deterministic = is_deterministic_loc | is_deterministic_glo;
   if (stages_loc){
      newmc->stageset = stages_loc;
   }else{
      newmc->stageset = stages_glo;
   }
   newmc->stochmodel = static_cast<StochModel*>(newmc->model);   
   if (newmc->stochmodel==NULL){
      cerr << "addStochInfo: dynamic cast failed!\n";
      exit(1);
   }
   stages_loc = NULL;
   is_deterministic_loc = false;
}


void
createSubdirTmpIfNotExist(void)
{
   int fl_is_dir;
   int fl_exists;
   struct stat sbuf;
  
   fl_exists = 1;
   if (stat("tmp", &sbuf) == -1) {
      fl_exists = 0;
   }
  
   if(S_ISDIR(sbuf.st_mode)) {
      fl_is_dir = 1;
      /*printf("File %s is a directory\n",argv[1]);*/
   }else{
      fl_is_dir = 0;
      /*printf("File %s is no directory\n",argv[1]);*/
   }

   if (fl_exists && !fl_is_dir){
      cerr << "'tmp/' exists but is no directory!\n";
      cerr << "Cannot continue\n";
      exit(1);
   }
   if (!fl_exists){
      int err;
      err = mkdir("tmp", S_IRWXU);
      if (err){
         cerr << "Failed to create temporary directory 'tmp/'\n";
         cerr << "Cannot continue\n";
         exit(1);
      }
   }

}
