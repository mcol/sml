%debug
%{
   #include <stdio.h>
   #include <stdlib.h>
   #include <assert.h>
   #include "nodes.h"
   #include "Set.h"
   #include "CompDescrParam.h"
   #include "AmplModel.h"
   #define YYERROR_VERBOSE
   int datalex(void);
   void dataerror(char *s);
   extern FILE *datain;
   extern int datalineno;
   static AmplModel *root;
   static bool logParse = false;
%}

%union
{
  long *ival;
  double *fval;
  char *string;
  opNode *opPtr;
  opNodeIx *opPtrIx;
}

%type <opPtr> number object set_elements set_name col_label
%type <opPtr> paramspec_list paramspec value_list value param_template_opt
%type <opPtr> value_table value_table_list col_label_list
 //%type <opPtr> entry_list entry string row_label

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITY COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE
%token NET_IN NET_OUT DIMEN ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED LOGICAL_OR LOGICAL_AND ELLIPSE
%token PUBLIC CORE DOT BEG TIMESTAGE RANDOM SUFFIX BLOCK IDREF IDREFM
%token SBLOCK USING DETERMINISTIC EXPECTATION STOCHASTIC STAGES
%token STAGE NODE
%token TR 
%token TOKPARAMSPECLIST TOKPARAMTEMPLATE TOKVALUETABLELIST
%token TOKVALUETABLE
%token <string> CHARACTER_STRING

%nonassoc SEMICOLON
%right ASSIGN
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NE
%left LT LE GT GE
%left '+' '-'
%left '*' '/'
%right POWER
%left '!'
%left ELLIPSE

//%expect 10

%%
 /* needs to come first, top level rule */

data_statements: /* empty */
          | data_statements data_statement 
          ;

 /* This is the definition of an object. 
"An object in a data specification may be either a number, or any character 
 string. [...] a character string may be specified by surrounding it with 
 quotes (' or ")". (AMPL book, p149) */
 /* Objects are set elements or values of parameters. 
    According to the AMPL book, values of paramteres are 'entries', which in 
    addition can be a "default" symbol. However, there is no way that the
    grammar can distinguish whether an object or an entry is specified;
    therefore object is used for both, the default symbol is processed later
 */

object: ID {
          $$ = new IDNode($1);
          if (logParse) cout << "Found 'object' of type ID: " << (void*)$$ << 
            ":" << $1 << "\n";
        }
      | CHARACTER_STRING {
          $$ = new IDNode($1);
          if (logParse) cout << "Found 'object' of type ID: " << (void*)$$ <<
            ":" << $1 << "\n";
        }
      | INT_VAL {
          $$ = (opNode *) new ValueNode<long>(*$1);
          if (logParse) cout << "Found 'object' of type INT_VAL: " << (void*)$$
            << ":" << *$1 << "\n";
        }
      | FLOAT_VAL {
          $$ = (opNode *) new ValueNode<double>(*$1);
          if (logParse) cout << "Found 'object' of type FLOAT_VAL: " <<
            (void*)$$ << ":" << *$1 << "\n";
        }
      ;





data_statement: data_paramdef SEMICOLON
              | data_paramdef_alt SEMICOLON
              | data_setdef SEMICOLON
              ;

data_setdef: SET ID DEFINED set_elements {
                //$2 is the set being defined
                //$4 are the set elements given as a ' ' node with list         
                SymbolTable::Entry *entry =
                  root->symbol_table.findSymbol($2);
                if (entry==NULL){
                  cerr << "Data given for set " << $2 << " which has not been"
                    "declared at top level!" << endl;
                  exit(1);
                }
                entry->mc->value = new Set($4);
              }
              

set_elements: /* empty */ {$$=NULL;}
           | set_elements object {
               $$ = addItemToListOrCreate(' ', $1, $2);
             }
           ;


/* This is the "normal" way of defining a parameter value, where only the
   name of the (one!) parameter is given, without a set definition at the
   same time */
data_paramdef: PARAM ID paramdefault_opt DEFINED paramspec_list {

                // try to find the correct param definition 
                // unclear what context to use: global at the moment
                SymbolTable::Entry *entry =
                  root->symbol_table.findSymbol($2);
                if (entry==NULL){
                  cerr << "Data given for parameter " << $2 << " which has "
                    "not beendeclared at top level!" << endl;
                  exit(1);
                }
                // reference has been found
                entry->mc->value = new CompDescrParam(entry->mc, $5); 
              }
            | PARAM ID paramdefault_opt value_table_list {
              /* This is an alternative (undocumented) form of the 
                 paramdeclaration without the ':='. 
                 Seems to just be used in the case where paramspec_list is 
                 actually a value_table_list.
                 In that case we would have a ":=:" which can be 
                 abbreviated to ":"                                        */

                // try to find the correct param definition 
                // unclear what context to use: global at the moment
                SymbolTable::Entry *entry =
                  root->symbol_table.findSymbol($2);
                if (entry==NULL){
                  cerr << "Data given for param " << $2 << " which has not"
                    "been declared at top level!" << endl;
                  exit(1);
                }
                // reference has been found
                // wrap the value_table_list in a single item paramspec_list
                opNode *on = new opNode(TOKPARAMSPECLIST, $4);
                entry->mc->value = new CompDescrParam(entry->mc, on);
              }
            ;
//data_paramdef_alt: PARAM paramdefault_opt COLON param_name_list DEFINED value_item_list

/* This is the alternative form of the parameter statement where set members
   are given at the same time as parameter values */
data_paramdef_alt: PARAM paramdefault_opt COLON param_name_list DEFINED value_list
//                 | PARAM paramdefault_opt COLON set_name COLON param_name_list DEFINED value_item_list
                 | PARAM paramdefault_opt COLON set_name COLON param_name_list DEFINED value_list
                // for now just simply scan the rhs. Rhs can be:
                // - single value (for scalar parameters)
                // - list of element/value pairs (for 1d arrays)
                // - list of tables of the form 
                //   ": col col := row val val row val val ...
                //   (for 2d arrays)
                // - tables involving templates
                //   [*,col,*] : col col := ...as above...

                 ;

param_name_list: ID
               | param_name_list ID
               ;
set_name: ID {$$=new IDNode($1);}

//value_item_list: value_item
//               | value_item_list value_item
//               ;    

//FIXME: this does not work! There is no way the grammar can work out which 
//       of the items listed in a paramdef is an object and which is an entry
//       We would need to look at the dimension of the sets involved and then
//       count
//       => object and entries treated the same, after the definition try
//          to analyse?

//value_item: object_list entry

value_list: /* empty */ {$$=NULL;}
          | value_list value {
              if ($1==NULL){
                $$ = new opNode(' ',$2);
              }else{
                if ($1->opCode==' '){
                  $$ = $1->push_back($2);
                }else{
                  $$ = new opNode(' ', $1, $2);
                }
              }
            }
          ;

paramdefault_opt: /* empty */
                | DEFAULT number
                ;

paramspec_list: /* empty */ {$$=NULL;}
              | paramspec_list paramspec {
                  if ($1==NULL){
                    $$ = new opNode(TOKPARAMSPECLIST, $2);
                  }else{
                    if ($1->opCode==TOKPARAMSPECLIST){
                      $$ = $1->push_back($2);
                    }else{        
                      $$ = new opNode(TOKPARAMSPECLIST, $1, $2);
                    }
                  }
                }
              ;

//paramspec: param_template_opt value_item_list
paramspec:  param_template_opt value value_list {
              opNode *vl;
              //printf("Executing value_list branch of paramspec\n");
              if ($3==NULL){
                vl = new opNode(' ', $2);
              }else{
                vl = $3->push_front($2);
              }
              if ($1!=NULL){
                $$ = new opNode(TOKPARAMTEMPLATE, $1, vl);
              }else{
                $$ = vl;
              }
            }
         |  param_template_opt value_table_list{
              cerr << "Executing wrong(?) value_table_list branch of "
                "paramspec\n";
              exit(1);
            }
         ;

value_table_list: value_table {
                    $$ = new opNode(TOKVALUETABLELIST, $1);
                  }
                | value_table_list value_table {
                    $$ = $1->push_back($2);
                  }  
                ;

//value_table: TR COLON col_label_list DEFINED value_table_row_list
//           | COLON col_label_list DEFINED value_table_row_list
//           ;
/* The parser cannot distinguisg between rows at this point. All it
   sees is a list of values. Hence the alternative below */

value_table: TR COLON col_label_list DEFINED value_list
           | COLON col_label_list DEFINED value_list {
               opNode *cll = $2;
               opNode *vl = $4;
               assert(cll->opCode=' ');
               assert(vl->opCode=' ');
               if (vl->nchild()%(cll->nchild()+1)!=0){
                 cerr << "DATA: error in line " << datalineno << ":\n";
                 cerr << "Length of value table (" << vl->nchild() << ")";
                 cerr << " not divisable by column labels +1 (" <<
                   cll->nchild()+1 << ")\n";
                 exit(1);
               }
               $$ = new opNode(TOKVALUETABLE, $2, $4);
             }
           ;

//tr_opt: /* empty */
//      | TR
//      ;

col_label_list: col_label {
                  assert($1);
                  $$ = new opNode(' ', $1);
                }
              | col_label_list col_label {
                  assert($1 && $1->opCode==' ');
                  $$ = $1->push_back($2);
                }
              ;

/*
value_table_row_list: value_table_row
                    | value_table_row_list value_table_row
                    ;

value_table_row: row_label entry_list
// I don't think the parser can distiguish between a row_label and the 
//   entry_list at this point. The parser would need to count the number
//   of col_labels given and assign a row_label every n entries. 
//   A \n at the end of a value_table_row is not mandatory, so cannot be used
//   to help in the distinction                                             


// an entry is an actual parameter value 

entry_list: entry {
              $$ = new opNode(' ',$1);}
          | entry_list entry{
              $$ = addItemToListNew($1, $2);}
          ;

entry: number {$$=$1;}
     | string {$$=$1;}
     | DOT {$$=new opNode(DOT, NULL);}
     ;
 
string: ID {$$=new IDNode($1);}

row_label: object

*/

param_template_opt: /* empty */
                  | param_template
                  ;
//      param_template is [*, A2, *] 
param_template: LSBRACKET templ_item_list RSBRACKET

templ_item_list: templ_item
               | templ_item_list COMMA templ_item
               ;

templ_item: object
          | '*'
          ;

col_label: object {
             $$=$1;
             if (logParse) cout << "Found 'col_label': " << (void*)$1 << "\n";
           }

value: object {
         $$=$1;
         if (logParse) cout << "Found 'value': " << (void *)$1 << "\n";
       }


/* an object is a member of a set that is used to identify which entry of
   a parameter array is to be defined */

//object_list: object
//           | object_list object
//           ;

//object: ID



//setlist_opt: /*empty*/
//           | COLON setlist
//           ;

//setlist: ID
//       | setlist ID
//       ;

//numberlist: number
//         | numberlist number
//         ;

number: INT_VAL {
  /* not entirly sure what is returned here as $1 */
  // Aparently a pointer to long int
          $$=(opNode *) new ValueNode<long>(*$1);
       }
     | FLOAT_VAL { 
         $$=(opNode *) new ValueNode<double>(*$1);
       }
//     | identifier { 
//          $$=new opNode(0, $1);
//       }
     | INFINITY { 
          $$ = new opNode(INFINITY);
       }
     ;

%%

//int datalex(void){
//  return yylex();
//}

//int datawrap(void){
//  return 1;
//}


void dataerror(char *s) {
  cerr << "DATA: " << s << " on line " << datalineno << "\n";
  //fprintf(stderr, "%s\n", s);
  exit(1);
}

void parse_data(AmplModel *current_model, char *datafilename){
        
  cout << "================================================================\n";
  cout << " Start parsing data file: " << datafilename << "\n";
  cout << "================================================================\n";

  datain = fopen(datafilename,"r");
  root = current_model;
  if (datain==NULL){
    cout << "ERROR: Data file '" << datafilename << "' not found\n";
    exit(1);
  }
          
  dataparse();
  cout << "================================================================\n";
  cout << " Finished parsing data file\n";
  cout << "================================================================\n";
  //exit(1);
}
